#!/usr/bin/zsh
### czhttpd
# zsh web server
# Author: jsks
# Site: https://github.com/jsks/czhttpd
###

# Clear env
for z in ${(SM)$(export)#*=}; do
    case ${z%=} in
        (PWD|_|HOME)
            continue;;
        (*)
            unset ${z%=};;
    esac
done

export PATH=/sbin:/bin:/usr/bin:/usr/local/bin

# Load Modules
zmodload zsh/datetime
zmodload zsh/files
zmodload zsh/parameter
zmodload zsh/stat
zmodload zsh/system
zmodload zsh/net/tcp
zmodload zsh/zselect

### zsh options
# unset:
#   multibyte - to accurately get length of utf8 strings
#   glob_dots - prevent iterating through dot files automatically
#   err_return - set only within `srv` to handle errors at highest level
#   multios - prevent redirecting file descriptor more than once (srv)
# set:
#   posix_jobs - for handling jobs in communicating child->parent
#   bare_glob_qual - required for our patterns in `list_dir`
#   local_options - selectively turn on multios & err_return
unsetopt multibyte glob_dots err_return multios
setopt posix_jobs bare_glob_qual local_options

# Declare variable types
integer logfd

typeset -A MTYPES HTTP_CODES
typeset -a LOG_FORMAT

typeset -g CONFIG DOCROOT

typeset -A req_headers
typeset -a conn_list

HTTP_CODES=( 200    "Ok"
             301    "Moved Permanently"
             400    "Bad Request"
             403    "Forbidden"
             404    "Not Found"
             408    "Request Timeout"
             413    "Request Entity Too Large"
             500    "Internal Server Error"
             501    "Not Implemented"
             503    "Service Unavailable"
             505    "HTTP Version Not Supported" )

readonly HTTP_CODES ARGV="$*"

### Platform specific code
# Ugly, but it beats having each function internally check $OSTYPE/zsystem
# each time it is invoked
case $OSTYPE in
    (linux*)
        function ip_addr() {
            local -a tcp_list ip
            local i k v

            tcp_list=("${(f@)$(</proc/net/tcp)}")

            for i in $tcp_list[2,-1]; do
                if [[ $i[7,14] != 00000000 && $i[7,14] != 0100007F ]]; then
                    for k v in "${(s..)i[7,14]}"; do
                        ip+="0x${(L)k}${(L)v}"
                    done

                    break
                fi
            done

            printf "%d.%d.%d.%d\n" ${(Oa)ip[@]}
        };;
    (darwin*|*bsd*)
        function ip_addr() {
            local line

            while read line; do
                if [[ ${line[(w)1]} == "inet"  && ${line[(w)2]} != "127.0.0.1" ]]; then
                    print ${line[(w)2]}
                    return
                fi
            done < <(ifconfig)
        };;
    (*)
        function ip_addr() {
            print "127.0.0.1"
        };;
esac

### Logging/info functions
function error() {
    setopt multios
    print "[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)] Fatal Error: $*" >&2 >&$logfd

    cleanup 2>/dev/null
    exit 113
}

function log_f() {
    print "${(e@)LOG_FORMAT} $*" >&$logfd
}

function log_err() {
    print "${(e@)LOG_FORMAT} Error -> $*" >&$logfd
}

function help() {
<<EOF
Usage: czhttpd [OPTIONS] <file or dir>

czhttpd - cloud's zsh http server

Options
    -c :    Config file location (default: ~/.config/czhttpd/main.conf)
    -h :    Print this help message
    -p :    Port to bind to (default: 8080)
    -v :    Redirect log messages to stdout

If no file or directory is given, czhttpd defaults to serving
the current directory.
EOF

exit
}

### Initialization functions
function parse_conf() {
    local i

    if [[ -f $1 ]]; then
        . $1 || error "Could not source config file $1"
    fi

    # Dumb, but cli args > config file
    [[ -n _PORT ]] && { PORT=$_PORT; unset _PORT }

    for i in PORT MAX_CONN HTTP_TIMEOUT HTTP_RECV_TIMEOUT HTTP_BODY_SIZE; do
        if [[ -n ${(P)i} && ${(P)i} != <-> ]]; then
            error "Invalid integer for $i"
        fi
    done

    for i in HTTP_KEEP_ALIVE HIDDEN_FILES FOLLOW_SYMLINKS LOG CACHE; do
        if [[ -n ${(P)i} && ${(P)i} != [01] ]]; then
            error "Invalid integer for $i"
        fi
    done

    # We need to check if logfd is a valid fd; however, default value
    # for integer is 0 so check that it isn't pointing to stdin
    if (( ! $logfd )) || [[ ! -t $logfd ]]; then
        if [[ -n $LOG_FILE && $LOG == 1 ]]; then
            if [[ -e $LOG_FILE && ! -f $LOG_FILE || ! -w $LOG_FILE ]]; then
                error "Invalid logging file $LOG_FILE"
            elif [[ ! -w ${LOG_FILE:h} ]]; then
                error "Cannot create logging file $LOG_FILE"
            fi

            : >> $LOG_FILE
            exec {logfd}>>$LOG_FILE
        else
            exec {logfd}>/dev/null
        fi
    fi
}

function parse_args() {
    local -A opts
    local i

    zparseopts -D -A opts c: p: h v || error "Failed to parse arguments" 2>/dev/null

    for i in ${(kM)opts}; do
        case $i in
            ("-c")
                [[ ! -f $opts[-c] ]] && error "Config file $opts[-c] does not exist"
                CONFIG="$opts[-c]";;
            ("-h")
                help;;
            ("-p")
                _PORT="$opts[-p]";;
            ("-v")
                exec {logfd}>&1;;
        esac
    done

    : ${CONFIG:=~/.config/czhttpd/conf/main.conf}

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        readonly -g DOCROOT="$1"
    else
        readonly -g DOCROOT="$PWD"
    fi
}

### Utility functions
function calc_size() {
    [[ -d "$1" ]] && { print "\-"; return }
    local KB MB GB size

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0

    size=$(stat -L +size $1)

    (( $size < $KB )) && { printf '%.1f%s\n' "${size}" "B" && return }
    (( $size < $MB )) && { printf '%.1f%s\n' "$((size/$KB))" "K" && return }
    (( $size < $GB )) && { printf '%.1f%s\n' "$((size/$MB))" "M" && return }
    (( $size > $GB )) && { printf '%.1f%s\n' "$((size/$GB))" "G" && return }
}

function mime_type() {
    [[ -h "${1%/}" ]] && print -n "symbolic link->"

    [[ -d "$1" ]] && { print "Directory"; return }

    local file_tail mtype

    file_tail="${(L)1:t}"
    if (( $+MTYPES[${file_tail#*.}] )); then
        print $MTYPES[${file_tail#*.}]
    else
        if which file >/dev/null; then
            mtype=$(file --mime-type -bL $1)

            case $mtype in
                (*"no read permission")
                    print "application/octet-stream";;
                ("text/"*)
                    print "text/plain";;
                (*)
                    print "${${mtype#application/x-executable}:-application/octet-stream}";;
            esac
        else
            print ${MTYPES[default]:-application/octet-stream}
        fi
    fi
}

# We can't use `zsystem flock` since child shells won't respect lock
function mklock() {
    [[ -n $LOCK ]] && return 1

    typeset -g LOCK=${1}.lock
    local timer_pid

    sleep 30 &
    timer_pid=$!

    while ! mkdir $LOCK 2>/dev/null; do
        if ! kill -0 $timer_pid 2>/dev/null; then
            return 1
        fi
    done

    kill $timer_pid 2>/dev/null
    return 0
}

function rmlock() {
    if [[ -n $LOCK ]]; then
        rmdir $LOCK; unset LOCK
    fi
}

function mtime() {
    stat -L -F "%d-%b-%Y %T" +mtime $1 2>/dev/null || print "\-"
}

function urldecode() {
    printf '%b\n' "${1:gs/%/\\x}"
}

### HTTP functions
# Suppress EPIPE, thanks.
function http_print() {
    print -n "$*\r\n" 2>/dev/null
}

function http_listen() {
    typeset -g listenfd

    if (( $PORT > 1024 )); then
        if [[ $PORT != ${$(ztcp -L)[(w)4]} || -z $listenfd ]]; then
            ztcp -c
            ztcp -l $PORT 2>/dev/null || error "Could not bind to port $PORT"
            print "Listening on $PORT"
            listenfd=$REPLY
        fi
    else
        error "Invalid port number, $PORT"
    fi
}

# Would be marginally quicker to use sysread + we would have better return
# values, but that would also add an insane amount of complexity
# (esp. wrt to pipelining).
#
# Ex: One of our shortcomings now is that we don't know why `read` (may)
# fail, so we can't return a 408 on timeout.
function parse_request() {
    setopt err_return

    unset req_headers; typeset -gA req_headers
    local method url version key value line buff

    read -t $HTTP_TIMEOUT -r -u $fd line

    for method url version in ${(s. .)line%$'\r'}; do
        req_headers[method]="$method"
        req_headers[url]="${url%\?*}"
        req_headers[querystr]="${(M)url%\?*}"
        req_headers[version]="$version"
    done

    while :; do
        read -t $HTTP_TIMEOUT -r -u $fd line
        [[ -z $line || $line == $'\r' ]] && break

        for key value in ${(s.: .)line%$'\r'}; do
            # Malformed request
            [[ -z $key || -z $value ]] && { error_header 400; return 1 }

            req_headers[${(L)key}]="$value"
        done
    done

    check_request

    if [[ $req_headers[transfer-encoding] == "chunked" ]]; then
        parse_chunk_body
    elif [[ -n $req_headers[content-length] ]]; then
        [[ $req_headers[content-length] != <-> ]] && { error_header 400; return 1 }
        (( $req_headers[content-length] > $HTTP_BODY_SIZE )) && { error_header 413; return 1 }

        sysread -t $HTTP_TIMEOUT -s $req_headers[content-length] -i $fd buff
        req_headers[msg-body]="${buff%$'\r'}"
    fi
}

function parse_chunk_body() {
    local line chunk_size buff
    local -i count=0 total=0

    while :; do
        # Find our hexadecimal first
        read -t $HTTP_TIMEOUT -r -u $fd line
        [[ -z ${line%$'\r'} ]] && continue

        # If 0 we're at the end
        [[ ${line%$'\r'} == 0 ]] && return 0

        # Convert hex and add \r\n to size
        chunk_size=$(($(printf '%d\n' 0x${line%$'\r'}) + 2))
        sysread -c count -t $HTTP_TIMEOUT -s $chunk_size -i $fd buff

        total+=$count
        (( $total > $HTTP_BODY_SIZE )) && { error_header 413; return 1 }

        req_headers[msg-body]+="${buff%$'\r'}"
        unset line
    done

    error_header 400
    return 1
}

function check_request() {
    if [[ -z $req_headers[url] || -z $req_headers[method] || -z $req_headers[version] ]]; then
        error_header 400
        return 1
    fi

    case $req_headers[version] in
        ($SERVER_PROTOCOL)
            [[ -z $req_headers[host] ]] && { error_header 400; return 1 };;
        (*)
            error_header 505
            return 1;;
    esac

    case $req_headers[method] in
        ("HEAD"|"GET"|"POST")
            return 0;;
        (*)
            error_header 501
            return 1;;
    esac
}

function return_header() {
    # This always needs to be set in order to deal with write errors
    setopt err_return

    local i

    http_print "$SERVER_PROTOCOL $1"

    if [[ $HTTP_KEEP_ALIVE == 0 ]]; then
        http_print "Connection: close"
    else
        http_print "Connection: ${req_headers[connection]:-keep-alive}"
    fi

    http_print "Date: $(export TZ=UTC && strftime "%a, %d %b %Y %H:%M:%S" $EPOCHSECONDS) GMT"
    http_print "Server: czhttpd"
    for i in "$@[2,-1]"; do
        http_print "$i"
    done
    http_print
}

function error_header() {
    if [[ -n $HTTP_CODES[$1] ]]; then
        log_f "$1 $HTTP_CODES[$1]"
        return_header "$1 $HTTP_CODES[$1]" "Content-type: text/plain; charset=UTF-8" $@[2,-1]
    else
        log_err "Could not find status code $1"
        return 1
    fi
}

### Dir listing functions
# Iterate through directory and add each file/subdir to shared array
# (quicker than redirecting `print` statements)
function build_index() {
    local -a index
    local i

    cd "$1"

    [[ "${1%/}" != "${DOCROOT%/}" ]] && html_fragment '/../'

    if (( $HIDDEN_FILES )); then
        for i in ./.*(-/NrT) ./.*(-.Nr); do
            html_fragment "$i"
        done
    fi

    for i in ./*(-/NrT) ./*(-.Nr); do
        html_fragment "$i"
    done

    cd -

    html_template "$1" $index
}

function html_template() {
    print "<!DOCTYPE html><html><head><style type="text/css"> a {text-decoration: none;} a:hover, a:focus { color: white; background: rgba(0,0,0,0.3); cursor: pointer; } h2 { margin-bottom: 10px } table { border-collapse: collapse; } thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; } thead th:nth-child(2) { text-align: left; padding-right: 12px; } tbody td:nth-child(2) { text-align: right; padding-right: 12px; } tbody td:first-child { padding-right: 30px; } div.list { background-color: #F5F5F5; border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; margin: 4px;} div.footer { font: 90% monospace; color: grey; font-style: italic; padding-left: 4px; }</style><title>czhttpd</title></head><body><h2>Index of $1</h2><div class=list><table><thead><tr><th>Name</th><th>Last-Modified</th><th>Size</th><th>Type</th></tr></thead><tbody>$@[2,-1]</tbody></table></div><div class=footer>$SERVER_SOFTWARE</div></body></html>"
}

function html_fragment() {
    index+="<tr><td><a href=\"${1#*/}\">${1#*/}</a></td><td>$(mtime $1)</td><td>$(calc_size $1)</td><td>$(mime_type $1)</td></tr>"
}

### Send
function send_file() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        <$1
    fi
}

function send_chunk() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local buff

        # Buffer output into 8K chunks using a pipe and sysread
        while sysread buff; do
            printf '%x\r\n' "${#buff}"
            printf '%s\r\n' "$buff"
        done

        printf '%x\r\n' "0"
        printf '\r\n'
    fi
}

### Wrapper functions
# send -> determines whether to send stream/file in chunks or as whole
# handler -> how to fulfill valid request (create directory listing or send a file etc etc)
# srv -> can we fulfill the request?
function __send() {
    if [[ -n $1 ]]; then
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Length: $fsize"
        send_file $1
    else
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Transfer-Encoding: chunked"
        send_chunk
    fi

    log_f "200"
}

function __handler() {
    local mtype fsize

    if [[ -f $1 ]]; then
        [[ -z $mtype ]] && mtype=$(mime_type $1)
        [[ -z $fsize ]] && fsize=$(stat -L +size $1)

        send $1
    else
        if (( $CACHE )); then
            local cache_file mod_time i

            cache_file="${CACHE_DIR}/${1//\//}-$(stat +mtime $1).html"
            : >> $cache_file
            mklock $cache_file

            if [[ ! -s $cache_file ]]; then
                rm $CACHE_DIR/${1//\//}-*.html || :
                build_index $1 > $cache_file
            fi

            rmlock

            { cd $CACHE_DIR; handler ${cache_file:t} } always { cd $DOCROOT }
        else
            mtype="text/html"
            send < <(build_index $1)
        fi
    fi
}

function __srv() {
    setopt err_return
    local pathname="${DOCROOT}$(urldecode ${1:-$req_headers[url]})"

    [[ $HIDDEN_FILES != "1" && ${pathname:t} == .* ]] && { error_header 403; return }
    [[ $FOLLOW_SYMLINKS != "1" && -h ${pathname%/} ]] && { error_header 403; return }

    { if [[ -f $pathname ]]; then
        handler $pathname
    elif [[ -d $pathname ]]; then
        if [[ $pathname != $DOCROOT && $pathname[-1] != "/" ]]; then
            error_header 301 "Location: http://$SERVER_ADDR:$PORT${pathname#$DOCROOT}/"
        elif [[ -f $pathname/$INDEX_FILE ]]; then
            handler $pathname/$INDEX_FILE
        else
            if [[ -r "$pathname" && -x "$pathname" ]]; then
                handler "$pathname"
            else
                error_header 403
            fi
        fi
    else
        error_header 404
    fi } always { [[ $? != 0 ]] && error_header 500 }
}

### Misc
# TRAPCHLD -> if child exits, connection has been closed so remove from our master array
# TRAPHUP -> signal to reload configuration
function cleanup() {
    setopt noerrreturn

    kill -15 ${(SM)jobstates##<->} 2>/dev/null

    log_f "> Exiting main"
    exec {logfd}>&-
    rm -rf $CACHE_DIR
    ztcp -c
}

function TRAPCHLD() {
    for i in $conn_list; kill -0 $i 2>/dev/null || conn_list=(${conn_list#$i})
}

function TRAPHUP() {
    exec {logfd}>&-
    cz_init || error "Failed to reload configuration"
}

### Main
# cz_init -> declare our default config vars in a function so that we can later reload everything
function cz_init() {
    LOG_FORMAT=( '[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)]'
                  '[pid: ${pid:-$sysparams[pid]}]'
                  '$client_ip'
                  '$req_headers[method]'
                  '$req_headers[url]'
                  '$req_headers[version]' )

    parse_args ${=ARGV}
    parse_conf $CONFIG

    log_f "> Initializing czhttpd"

    # Default callback functions, allows modules to override how we handle requests
    # Can't be simple aliases since shell won't find the cmd
    ! typeset -f send >/dev/null && function send() { __send $* }
    ! typeset -f handler >/dev/null && function handler() { __handler $* }
    ! typeset -f srv >/dev/null && function srv() { __srv $* }

    log_f "MAX_CONN: ${MAX_CONN:=12}"
    log_f "PORT: ${PORT:=8080}"
    log_f "IP_REDIRECT: ${IP_REDIRECT:=$(ip_addr)}"
    log_f "IP_ACCEPT: ${IP_ACCEPT:=[0-9*].[0-9*].[0-9*].[0-9*]}"
    log_f "HTTP_KEEP_ALIVE: ${HTTP_KEEP_ALIVE:=1}"
    log_f "HTTP_TIMEOUT: ${HTTP_TIMEOUT:=30}"
    log_f "HTTP_RECV_TIMEOUT: ${HTTP_RECV_TIMEOUT:=5}"
    log_f "HTTP_BODY_SIZE: ${HTTP_BODY_SIZE:=16384}"
    log_f "INDEX_FILE: ${INDEX_FILE:=index.html}"
    log_f "HIDDEN_FILES: ${HIDDEN_FILES:=0}"
    log_f "FOLLOW_SYMLINKS: ${FOLLOW_SYMLINKS:=0}"
    log_f "CACHE: ${CACHE:=0}"
    log_f "CACHE_DIR: ${CACHE_DIR:=/tmp/.czhttpd-$$/}"
    log_f "LOG_FILE: ${LOG_FILE:=/dev/null}"

    # Convert our timeout from seconds
    ZSELECT_TIMEOUT=$(($HTTP_TIMEOUT*100))

    # readonly vars that should not be modified by anything except this f()
    typeset +r -g SERVER_NAME="$IP_REDIRECT"
    typeset +r -g SERVER_ADDR="$SERVER_NAME"
    typeset +r -g SERVER_SOFTWARE="czhttpd/$(printf '%.1f\n' "$((RANDOM/10000.0))")b"
    typeset +r -g SERVER_PROTOCOL="HTTP/1.1"
    readonly -g SERVER_NAME SERVER_ADDR SERVER_SOFTWARE SERVER_PROTOCOL

    if [[ -z $MTYPES ]]; then
        MTYPES=( pdf       application/pdf
                 gz        application/x-gzip
                 tar.gz    application/x-tgz
                 tgz       application/x-tgz
                 tar       application/x-tar
                 zip       application/zip
                 gif       image/gif
                 jpeg      image/jpeg
                 jpg       image/jpeg
                 png       image/png
                 css       text/css
                 html      text/html
                 htm       text/html
                 js        text/javascript
                 sh        text/plain
                 py        text/plain
                 pl        text/plain
                 log       text/plain
                 conf      text/plain
                 text      text/plain
                 txt       text/plain
                 default   application/octet-stream )
    fi

    if (( $CACHE )) && [[ ! -d $CACHE_DIR ]]; then
        mkdir $CACHE_DIR || error "Failed to create cache dir"
    fi
}

trap "cleanup 2>/dev/null; exit" INT KILL TERM; trap '' PIPE

cz_init || error "Failed to initialize czhttpd"
http_listen

while :; do
    # Use select to block since interrupting `ztcp -a` crashes our script. We
    # really should be using '-t' but ztcp polling is broken in OSX
    { zselect -r $listenfd && ztcp -a $listenfd } || continue

    fd=$REPLY

    if (( ${#conn_list} >= $MAX_CONN )); then
        error_header 503 >&$fd
        ztcp -c $fd
        continue
    fi

    ( trap "ztcp -c; rmlock 2>/dev/null; exit" KILL TERM INT EXIT; trap '' PIPE; trap - CHLD HUP

    # Explicitly save pid so that `srv` logs the same pid even though it is run in subshell
    pid=$sysparams[pid]

    while :; do
        zselect -t $ZSELECT_TIMEOUT -r $fd || { error_header 408 >&$fd; break }

        # How do we want to handle stderr?
        parse_request >&$fd

        # err_return breaks when we use `cmd1 || cmd2`
        [[ $? != 0 ]] && break

        # TODO: prevent `srv` from being executed as a subshell
        #  - Problem: want to log error msgs at highest level
        #             BUT can't use process sub since subshell
        #             won't have a copy of `logfd`
        srv 2>&1 >&$fd | sysread buff
        lstatus=$pipestatus[1]

        [[ -n $buff ]] && { log_err "${(f)buff}"; unset buff }
        [[ $HTTP_KEEP_ALIVE == 0 || $req_headers[connection] == "close" || $lstatus != 0 ]] && break
    done ) &

    conn_list+=$!
    ztcp -c $fd
done

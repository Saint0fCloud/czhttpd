#!/usr/bin/env zsh
#
# czhttpd - zsh web server
#
# Author: jsks
# Site: https://github.com/jsks/czhttpd
###

emulate -R zsh

# Several accumulated bug fixes since 5.6
if [[ $ZSH_VERSION < 5.6 ]]; then
    print 'Incompatible zsh version'
    exit 113
fi

# Clear env
for z in ${(SM)$(export)#*=}; do
    case ${z%=} in
        (PWD|_|HOME)
            continue;;
        (*)
            unset ${z%=};;
    esac
done

export PATH=/sbin:/bin:/usr/bin:/usr/local/bin

# Load Modules
ml=(datetime files parameter stat system net/tcp zutil)
for i in $ml; zmodload zsh/$i || exit 127

### zsh options
# unset:
#   multibyte - to accurately get length of utf8 strings
#   glob_dots - prevent iterating through dot files automatically
#   err_return - set only within `srv` to handle errors at highest level
# set:
#   posix_jobs - for handling jobs in communicating child->parent
#   bare_glob_qual - required for our patterns in `list_dir`
#   local_options - selectively turn on multios & err_return
#   extended_glob - to allow negation case statement patterns
unsetopt multibyte glob_dots err_return
setopt posix_jobs bare_glob_qual local_options extended_glob

# Declare global variable types
typeset -A MTYPES HTTP_CODES
typeset -a LOG_FORMAT

typeset CONFIG DOCROOT STDOUT

typeset IP_REDIRECT PORT MAX_CONN \
        HTTP_KEEP_ALIVE HTTP_TIMEOUT HTTP_RECV_TIMEOUT HTTP_BODY_SIZE \
        INDEX_FILE HIDDEN_FILES FOLLOW_SYMLINKS \
        LOG_FILE CACHE CACHE_DIR

typeset -A req_headers
typeset -a conn_list

integer logfd

HTTP_CODES=( 200    "Ok"
             301    "Moved Permanently"
             400    "Bad Request"
             403    "Forbidden"
             404    "Not Found"
             413    "Request Entity Too Large"
             500    "Internal Server Error"
             501    "Not Implemented"
             503    "Service Unavailable"
             505    "HTTP Version Not Supported" )

readonly HTTP_CODES ARGV="$*"

### Platform specific code
function ip_addr() {
    case $OSTYPE in
        (linux*)
            local -a tcp_list ip
            local i k v

            tcp_list=("${(f@)$(</proc/net/tcp)}")

            for i in $tcp_list[2,-1]; do
                if [[ $i[7,14] != 00000000 && $i[7,14] != 0100007F ]]; then
                    for k v in "${(s..)i[7,14]}"; do
                        ip+="0x${(L)k}${(L)v}"
                    done

                    break
                fi
            done

            printf "%d.%d.%d.%d\n" ${(Oa)ip[@]};;
        (darwin*|*bsd*)
            local line

            while read line; do
                if [[ ${line[(w)1]} == "inet"  && ${line[(w)2]} != "127.0.0.1" ]]; then
                    print ${line[(w)2]}
                    return
                fi
            done < <(ifconfig);;
        (*)
            print "127.0.0.1";;
    esac
}

### Logging/info functions
function error() {
    local cur_time
    setopt multios
    get_time

    print "[$cur_time] Fatal Error: $*" >&2 >&$logfd

    cleanup 2>/dev/null
    exit 113
}

# Check that we have a valid fd and reset if necessary (ex: logging
# within process substitution).
function check_logfd() {
    if ! print -nu $logfd 2>/dev/null; then
        if (( STDOUT )); then
            exec {logfd}>&1
        else
            exec {logfd}>>$LOG_FILE
        fi
    fi
}

function log_f() {
    local cur_time

    check_logfd
    get_time

    print -u $logfd "${(e@)LOG_FORMAT} $*"
}

function log_err() {
    local cur_time

    check_logfd
    get_time

    print -u $logfd "${(e@)LOG_FORMAT} Error -> $*"
}

function capture_stderr() {
    local pid buf

    pid=$sysparams[ppid]
    sysread buf

    [[ -n $buf ]] && log_err "${(f)buf}"
}

function help() {
<<EOF
Usage: czhttpd [OPTIONS] <file or dir>

czhttpd - cloud's zsh http server

Options
    -c :    Optional configuration file (default: ~/.config/czhttpd/main.conf)
    -h :    Print this help message
    -p :    Port to bind to (default: 8080)
    -v :    Redirect log messages to stdout

If no file or directory is given, czhttpd defaults to serving
the current directory.
EOF

exit
}

### Initialization functions
function parse_conf() {
    local i

    if [[ -f $1 ]]; then
        . $1 || error "Could not source config file $1"
    fi

    # Dumb, but cli args > config file
    [[ -n _PORT ]] && { PORT=$_PORT; unset _PORT }

    for i in PORT MAX_CONN HTTP_TIMEOUT HTTP_RECV_TIMEOUT HTTP_BODY_SIZE; do
        if [[ -n ${(P)i} && ${(P)i} != <-> ]]; then
            error "Invalid integer for $i"
        fi
    done

    for i in HTTP_KEEP_ALIVE HIDDEN_FILES FOLLOW_SYMLINKS CACHE; do
        if [[ -n ${(P)i} && ${(P)i} != [01] ]]; then
            error "Invalid integer for $i"
        fi
    done

    if (( STDOUT )); then
        exec {logfd}>&1
    elif [[ -n $LOG_FILE ]]; then
        if [[ $LOG_FILE == "/dev/null" ]]; then
            :
        elif [[ -e $LOG_FILE && (! -f $LOG_FILE || ! -w $LOG_FILE) ]]; then
            error "Invalid logging file: $LOG_FILE"
        elif [[ ! -w ${LOG_FILE:h} ]]; then
            error "Cannot create logging file: $LOG_FILE"
        fi

        : >> $LOG_FILE
        exec {logfd}>>$LOG_FILE
    else
        exec {logfd}>/dev/null
    fi
}

function parse_args() {
    local -A opts
    local i

    zparseopts -D -A opts c: p: h v || error "Failed to parse arguments" 2>/dev/null

    for i in ${(kM)opts}; do
        case $i in
            ("-c")
                [[ ! -f $opts[-c] ]] && error "Config file $opts[-c] does not exist"
                CONFIG="$opts[-c]";;
            ("-h")
                help;;
            ("-p")
                _PORT="$opts[-p]";;
            ("-v")
                STDOUT=1;;
        esac
    done

    : ${CONFIG:=~/.config/czhttpd/conf/main.conf}

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        typeset +r -g DOCROOT="$1"
        readonly -g DOCROOT
    else
        typeset +r -g DOCROOT="$PWD"
        readonly -g DOCROOT
    fi
}

### Utility functions
# Dear reader, I apologize in advance for this, but all of these utility
# functions modify scoped variables rather than return (`print`) values.
# Subshells are expensive and we care about latency, remember to declare vars in
# calling f().

###
# Calculate size of file in appropriate units.
#   @Sets var -> `fsize`
function calc_size() {
    [[ -d "$1" ]] && { fsize="-"; return }
    local -F KB MB GB
    local -a stat_size

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0

    stat -A stat_size -L +size $1
    local -F 1 stat_size=$stat_size

    (( stat_size < KB )) && { fsize="${stat_size}B"; return }
    (( stat_size < MB )) && { ((stat_size/=KB)); fsize="${stat_size}K"; return }
    (( stat_size < GB )) && { ((stat_size/=MB)); fsize="${stat_size}M"; return }
    (( stat_size > GB )) && { ((stat_size/=GB)); fsize="${stat_size}G"; return }
}

###
# Formatted time string
#   @Sets var -> `cur_time`
function get_time() {
    strftime -s cur_time "%a %d %b, %H:%M:%S" $EPOCHSECONDS
}

###
# Mime type according to first, our global mtype array, and second `file`
#   @Sets var -> `mtype`
function mime_type() {
    [[ -h "${1%/}" ]] && mtype="symbolic link->"

    [[ -d "$1" ]] && { mtype+="Directory"; return }

    local tail file_mime

    tail="${(L)1:t}"
    if [[ -n $MTYPES[${tail#*.}] ]]; then
        mtype+="$MTYPES[${tail#*.}]"
    else
        if which file >/dev/null; then
            file_mime=$(file --mime-type -bL $1)

            case $file_mime in
                (*"no read permission")
                    mtype+="application/octet-stream";;
                ("text/"*)
                    mtype+="text/plain";;
                (*)
                    mtype+="${${mtype#application/x-executable}:-application/octet-stream}";;
            esac
        else
            mtype+="${MTYPES[default]:-application/octet-stream}"
        fi
    fi
}

###
# Lock using mkdir
#   @Sets var -> LOCK
#
#   Note:
#       - We can't use `zsystem flock` since child shells won't respect lock
#       - LOCK will be declared global so that all f()s have access
function mklock() {
    typeset -g LOCK=${1}.lock
    local timer_pid

    sleep 30 &
    timer_pid=$!

    while ! mkdir $LOCK 2>/dev/null; do
        if ! kill -0 $timer_pid 2>/dev/null; then
            return 1
        fi

        sleep 0.01
    done

    kill $timer_pid 2>/dev/null
    return 0
}

###
# Unlock using rmdir
#   @Unsets var -> LOCK
function rmlock() {
    if [[ -n $LOCK ]]; then
        rmdir $LOCK; unset LOCK
    fi
}

###
# Formatted last modification time for file
#   @Sets array -> mtime
function mod_time() {
    stat -A mtime -L -F "%d-%b-%Y %T" +mtime $1 2>/dev/null || print "\-"
}

###
# Decode url
#   @Sets var -> decoded_url
function urldecode() {
    printf -v decoded_url '%b' "${1:gs/%/\\x}"
}

### HTTP functions
function http_listen() {
    typeset -g listenfd

    if (( PORT > 1024 )); then
        if [[ $PORT != ${$(ztcp -L)[(w)4]} || -z $listenfd ]]; then
            ztcp -c
            ztcp -l $PORT 2>/dev/null || error "Could not bind to port $PORT"
            print "Listening on $PORT"
            listenfd=$REPLY
        fi
    else
        error "Invalid port number, $PORT"
    fi
}

function parse_ztcp() {
    unset client_ip; typeset -g client_ip
    local ip_line

    sessions=$(ztcp -L)
    for ip_line in ${(f@)sessions}; do
        [[ $ip_line[3] == "I" ]] && { client_ip=${ip_line[(w)3]}; break }
    done
}

###
# Would be marginally quicker to use sysread + we would have better return
# values, but that would also add an insane amount of complexity (esp. wrt
# pipelining).
#
# Ex: One of our shortcomings now is that we don't know why read may
# fail, so we can't return a 408 on timeout. Instead we just
# incorrectly blanket return 400 for all errors encountered when
# parsing a request.
function parse_request() {
    unset req_headers; typeset -gA req_headers
    local method url version key value line

    # Use HTTP_TIMEOUT for first read since we're blocking until
    # initial bytes from request. We only return 400 when client has
    # sent data since we may hit EOF when keep-alive is enabled and
    # client has closed connection after single request. If client
    # closes in the middle of any other reads, send 400 and simply
    # suppress EPIPE.
    read -t $HTTP_TIMEOUT -r -u $fd line || {
        [[ -n $line ]] && error_header 400
        return 1
    }

    for method url version in ${(s. .)line%$'\r'}; do
        req_headers[method]="$method"
        req_headers[url]="${url%\?*}"
        req_headers[querystr]="${(M)url%\?*}"
        req_headers[version]="$version"
    done

    while :; do
        read -t $HTTP_RECV_TIMEOUT -r -u $fd line || { error_header 400; return 1 }
        [[ -z $line || $line == $'\r' ]] && break

        for key value in ${(s.: .)line%$'\r'}; do
            # Malformed request
            [[ -z $key || -z $value ]] && { error_header 400; return 1 }

            req_headers[${(L)key}]="${=value}"
        done
    done

    if [[ $req_headers[transfer-encoding] == "chunked" ]]; then
        parse_req_body_chunked
    elif [[ -n $req_headers[content-length] ]]; then
        parse_req_body_fixed
    fi
}

function parse_req_body_chunked() {
    local buff line
    local -i count total offset chunk_size

    while :; do
        # Find our hexadecimal first
        read -t $HTTP_RECV_TIMEOUT -r -u $fd line || { error_header 400; return 1 }
        [[ -z ${line%$'\r'} ]] && continue

        # If 0 we're at the end
        [[ ${line%$'\r'} == 0 ]] && return 0

        # Convert hex
        chunk_size=$(printf '%d\n' 0x${line%$'\r'})

        # Set bufsize to $chunk_size; h/o, sysread not guaranteed to read
        # that many bytes so loop
        while :; do
            sysread -c count -t $HTTP_RECV_TIMEOUT -s $chunk_size -i $fd buff || {
                error_header 400; return 1
            }

            total+=$count
            req_headers[msg-body]+="$buff"

            # When chunk_size == 0 we've read the right amount
            (( ! (chunk_size-=count) )) && break
        done

        # Throw away CRLF
        offset=2
        while :; do
            sysread -c count -o 1 -t $HTTP_RECV_TIMEOUT -s $offset -i $fd >/dev/null
            (( ! (offset-=count) )) && break
        done

        (( total > HTTP_BODY_SIZE )) && { error_header 413; return 1 }
        unset line
    done

    error_header 400
    return 1

}


function parse_req_body_fixed() {
    local buff
    local -i count total bufsize

    local -i bufsize

    [[ $req_headers[content-length] != <-> ]] && { error_header 400; return 1 }
    (( req_headers[content-length] > HTTP_BODY_SIZE )) && { error_header 413; return 1 }

    # Same; we can't guarantee that sysread will read $bufsize in one go.
    bufsize=$req_headers[content-length]
    while :; do

        # This is ugly, but we want to break without error if body < length;
        # requires extended_glob
        sysread -c count -t $HTTP_RECV_TIMEOUT -s $bufsize -i $fd buff || {
            case $? in
                (4)
                    break;;
                (^0)
                    return 1;;
            esac
        }

        req_headers[msg-body]+="$buff"
        total+=$count

        (( ! (bufsize-=count) )) && break
    done

    (( total != $req_headers[content-length] )) && { error_header 400; return 1 }

    return 0
}

function check_request() {
    if [[ -z $req_headers[url] || -z $req_headers[method] || -z $req_headers[version] ]]; then
        error_header 400
        return 1
    fi

    case $req_headers[version] in
        ($SERVER_PROTOCOL)
            [[ -z $req_headers[host] ]] && { error_header 400; return 1 };;
        (*)
            error_header 505
            return 1;;
    esac

    case $req_headers[method] in
        ("HEAD"|"GET"|"POST")
            return 0;;
        (*)
            error_header 501
            return 1;;
    esac
}

function return_header() {
    local i cur_time resp_headers
    local -x TZ=UTC
    get_time

    resp_headers+="$SERVER_PROTOCOL $1\r\n"

    if (( HTTP_KEEP_ALIVE )); then
        resp_headers+="Connection: ${req_headers[connection]:-keep-alive}\r\n"
    else
        resp_headers+="Connection: close\r\n"
    fi

    resp_headers+="Date: $cur_time GMT\r\n"
    resp_headers+="Server: czhttpd\r\n"

    for i in "$@[2,-1]"; resp_headers+="$i\r\n"

    # Suppress EPIPE, thanks.
    print -n "$resp_headers\r\n" 2>/dev/null
}

function error_header() {
    if [[ -n $HTTP_CODES[$1] ]]; then
        return_header "$1 $HTTP_CODES[$1]" "Content-type: text/plain; charset=UTF-8" "Content-length: $(( ${#1} + ${#HTTP_CODES[$1]} + 1))" $@[2,-1]

        # Suppress EPIPE here too.
        print -n "$1 $HTTP_CODES[$1]" 2>/dev/null
        log_f "$1 $HTTP_CODES[$1]"
    else
        log_err "Could not find status code $1"
        return 1
    fi
}

### Dir listing functions
# Iterate through directory and add each file/subdir to shared str (quicker than
# redirecting `print` statements; also faster than shared array)
function build_index() {
    local i index

    cd "$1"

    [[ "${1%/}" != "${DOCROOT%/}" ]] && html_fragment '../'

    if (( HIDDEN_FILES )); then
        for i in .*(-/NrT) .*(-.Nr); html_fragment "$i"
    fi

    for i in *(-/NrT) *(-.Nr); html_fragment "$i"

    cd -

    print -n "<!DOCTYPE html><html><head><style type="text/css"> a {text-decoration: none;} a:hover, a:focus { color: white; background: rgba(0,0,0,0.3); cursor: pointer; } h2 { margin-bottom: 10px } table { border-collapse: collapse; } thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; } thead th:nth-child(2) { text-align: left; padding-right: 12px; } tbody td:nth-child(2) { text-align: right; padding-right: 12px; } tbody td:first-child { padding-right: 30px; } div.list { background-color: #F5F5F5; border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; margin: 4px;} div.footer { font: 90% monospace; color: grey; font-style: italic; padding-left: 4px; }</style><title>czhttpd</title></head><body><h2>Index of $1</h2><div class=list><table><thead><tr><th>Name</th><th>Last-Modified</th><th>Size</th><th>Type</th></tr></thead><tbody>${index[@]}</tbody></table></div><div class=footer>$SERVER_SOFTWARE</div></body></html>"
}

function html_fragment() {
    local mtype fsize
    local -a mtime

    mod_time $1
    calc_size $1
    mime_type $1

    index+="<tr><td><a href=\"$1\">$1</a></td><td>$mtime</td><td>$fsize</td><td>$mtype</td></tr>"
}

### Send
# Quicker to send using `sysread` rather than redirection (ex: `<$1`)
function send_file() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local -i filefd
        exec {filefd}<$1

        { while :; do
            sysread -i $filefd -o 1 || {
                case $? in
                    (5)
                        return 0;;
                    (^0)
                        return 1;;
                esac
            }
        done } always { exec {filefd}>&- }
    fi
}

function send_chunk() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local buff

        # Buffer output into 8K chunks using a pipe and sysread
        while sysread buff; do
            printf '%x\r\n' "${#buff}"
            printf '%s\r\n' "$buff"
        done

        printf '%x\r\n' "0"
        printf '\r\n'
    fi
}

### Wrapper functions
# Determines whether to send stream/file in chunks or as whole
function __send() {
    if [[ -n $1 ]]; then
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Length: $fsize"
        send_file $1
    else
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Transfer-Encoding: chunked"
        send_chunk
    fi

    log_f "200"
}

###
# How to fulfill valid request (create directory listing or send a file etc etc)
function __handler() {
    if [[ -f $1 ]]; then
        local mtype
        local -a fsize

        [[ -z $mtype ]] && mime_type $1
        [[ -z $fsize ]] && stat -A fsize -L +size $1

        send $1
    else
        if (( CACHE )); then
            local cache_file="${CACHE_DIR}/${1//\//}.html"
            if [[ $cache_file -ot $1 || ! -f $cache_file ]]; then
                mklock $cache_file
                build_index $1 > $cache_file
                rmlock
            fi

            { cd $CACHE_DIR; handler ${cache_file:t} } always { cd $DOCROOT }
        else
            mtype="text/html"
            send < <(build_index $1)
        fi
    fi
}

###
# Can we fulfill the request?
function __srv() {
    local pathname decoded_url

    urldecode ${1:-$req_headers[url]}
    pathname="${DOCROOT}$decoded_url"

    [[ $HIDDEN_FILES != 1 && ${pathname:t} == .* ]] && { error_header 403; return }
    [[ $FOLLOW_SYMLINKS != 1 && -h ${pathname%/} ]] && { error_header 403; return }

    { if [[ -f ${pathname%/} ]]; then
          handler ${pathname:A}
      elif [[ -d $pathname ]]; then
          if [[ $pathname != $DOCROOT && $pathname[-1] != "/" ]]; then
              error_header 301 "Location: http://$SERVER_ADDR:$PORT${pathname#$DOCROOT}/"
          elif [[ -f $pathname/$INDEX_FILE ]]; then
              handler $pathname/$INDEX_FILE
          else
              if [[ -r "$pathname" && -x "$pathname" ]]; then
                  handler "$pathname"
              else
                  error_header 403
              fi
          fi
      else
          error_header 404
      fi } always { [[ $? != 0 ]] && error_header 500 }
}

### Misc
function cleanup() {
    setopt noerrreturn

    kill -15 ${(SM)jobstates##<->} 2>/dev/null

    log_f "> Exiting main"
    rm -rf $CACHE_DIR
    ztcp -c
}

###
# Signal to reload configuration
function TRAPHUP() {
    cz_init || error "Failed to reload configuration"
}

### Main
# Declare our default config vars in a function so that we can later reload
function cz_init() {
    LOG_FORMAT=(  '[$cur_time]'
                  '[pid: ${pid:-$sysparams[pid]}]'
                  '$client_ip'
                  '$req_headers[method]'
                  '$req_headers[url]'
                  '$req_headers[version]' )

    parse_args ${=ARGV}
    parse_conf $CONFIG

    log_f "> Initializing czhttpd"

    # Default callback functions, allows modules to override how we handle
    # requests. Can't be simple aliases since shell won't find the cmd
    ! typeset -f send >/dev/null && function send() { __send $* }
    ! typeset -f handler >/dev/null && function handler() { __handler $* }
    ! typeset -f srv >/dev/null && function srv() { __srv $* }

    log_f "MAX_CONN: ${MAX_CONN:=12}"
    log_f "PORT: ${PORT:=8080}"
    log_f "IP_REDIRECT: ${IP_REDIRECT:=$(ip_addr)}"
    log_f "HTTP_KEEP_ALIVE: ${HTTP_KEEP_ALIVE:=1}"
    log_f "HTTP_TIMEOUT: ${HTTP_TIMEOUT:=30}"
    log_f "HTTP_RECV_TIMEOUT: ${HTTP_RECV_TIMEOUT:=5}"
    log_f "HTTP_BODY_SIZE: ${HTTP_BODY_SIZE:=16384}"
    log_f "INDEX_FILE: ${INDEX_FILE:=index.html}"
    log_f "HIDDEN_FILES: ${HIDDEN_FILES:=0}"
    log_f "FOLLOW_SYMLINKS: ${FOLLOW_SYMLINKS:=0}"
    log_f "CACHE: ${CACHE:=0}"
    log_f "CACHE_DIR: ${CACHE_DIR:=/tmp/.czhttpd-$$/}"
    log_f "LOG_FILE: ${LOG_FILE:=/dev/null}"

    # readonly vars that should not be modified by anything except this f()
    typeset +r -g SERVER_NAME="$IP_REDIRECT"
    typeset +r -g SERVER_ADDR="$SERVER_NAME"
    typeset +r -g SERVER_SOFTWARE="czhttpd/$(printf '%.1f\n' "$((RANDOM/10000.0))")b"
    typeset +r -g SERVER_PROTOCOL="HTTP/1.1"
    readonly -g SERVER_NAME SERVER_ADDR SERVER_SOFTWARE SERVER_PROTOCOL

    if [[ -z $MTYPES ]]; then
        MTYPES=( pdf       application/pdf
                 gz        application/x-gzip
                 tar.gz    application/x-tgz
                 tgz       application/x-tgz
                 tar       application/x-tar
                 zip       application/zip
                 gif       image/gif
                 jpeg      image/jpeg
                 jpg       image/jpeg
                 png       image/png
                 css       text/css
                 html      text/html
                 htm       text/html
                 js        text/javascript
                 sh        text/plain
                 py        text/plain
                 pl        text/plain
                 log       text/plain
                 conf      text/plain
                 text      text/plain
                 txt       text/plain
                 default   application/octet-stream )
    fi

    if (( CACHE )) && [[ ! -d $CACHE_DIR ]]; then
        mkdir $CACHE_DIR || error "Failed to create cache dir"
    fi
}

trap "cleanup 2>/dev/null; exit" INT TERM KILL EXIT; trap '' PIPE

cz_init || error "Failed to initialize czhttpd"
http_listen

while :; do
    ztcp -a $listenfd
    fd=$REPLY

    parse_ztcp

    if (( ${#jobstates} >= MAX_CONN )); then
        error_header 503 >&$fd
        ztcp -c $fd
        continue
    fi

    (trap "ztcp -c; rmlock 2>/dev/null; exit" INT TERM KILL EXIT
     trap '' PIPE; trap - CHLD HUP

     setopt err_return

     while :; do
         # err_return does not work in condition expressions, see:
         # http://www.zsh.org/mla/users/2012/msg00816.html
         parse_request
         check_request
         srv

         [[ $HTTP_KEEP_ALIVE == 0 || $req_headers[connection] == "close" ]] && \
             break
     done) >&$fd 2> >(capture_stderr) &

    ztcp -c $fd
done

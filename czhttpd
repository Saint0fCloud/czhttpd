#!/usr/bin/env zsh
# zsh http server

zmodload zsh/net/tcp
zmodload zsh/stat
zmodload zsh/datetime
zmodload zsh/zselect

export TZ=UTC

integer logfd
integer fifofd

# Defaults
DEF_PORT=8080   # Port
DEF_CONNS=4     # Max Connections
DEF_TIME=90     # TCP Timeout

FIFO=/tmp/czhttpd.fifo

# Functions
function error() {
    print "Error: $*" >&2
    ztcp -c
    exit 113
}

function logger() {
    print "$*" >&$logfd
}

function help() {
cat <<EOF
Usage: czhttpd [OPTIONS] <optional file or dir>

Options:
    -p :    Port to bind to (default 8080)
    -c :    Max number of connections to accept (default 4)
    -t :    Connection timeout in seconds (default 90)
    -l :    Enable logging to existing file
    -v :    Enable verbose output
    -h :    Print this help message

czhttpd can optionally serve a given file or directory, otherwise the current
working directory will be recursively served.
EOF

exit
}

function parse_args() {
    zparseopts -K -D -A OPTS p: c: t: l: h v || exit

    [[ -n ${(kM)OPTS:#-h} ]] && help

    for i in ${(k)OPTS}; do
        case $i in
            (-c|-t)
                [[ $OPTS[$i] != <-> ]] && error "$OPTS[$i]i is not a valid integer";;
            (-p)
                [[ $OPTS[$i] != <-> || $OPTS[$i] < 1024 ]] && error "$OPTS[$i] is not a valid port number.";;
            (-v)
                VERBOSE=1;;
            (-l)
                LOG=1
                [[ ! -f $OPTS[$i] ]] && error "File $OPTS[$i] does not exist.";;
        esac
    done

    MAX_CONNECTIONS=${OPTS[-c]:-$DEF_CONNS}
    PORT=${OPTS[-p]:-$DEF_PORT}
    TIMEOUT=${OPTS[-t]:-$DEF_TIME}
    LOGFILE=${OPTS[-l]:-null}

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        DOCROOT="$1"
    else
        DOCROOT="$PWD"
    fi
}

function http_listen() {
    ztcp -l $PORT 2>/dev/null || error "Could not bind to port $PORT"
    print "Listening on $PORT" && logger "Port: $PORT"
    listenfd=$REPLY
}


function parse_header() {
    read -t $TIMEOUT -r -u $fd method url version || return 1
    print method $method
    print url $url
    print version $version

    while read -r -u $fd line; do
        [[ -n $line && $line != $'\r' ]] || break
        print ${line%$'\r'}
    done

    return 0
}

function return_header() {
    print -n "HTTP/1.1 $1\r\n"
    print -n "Connection: keep-alive\r\n"
    print -n "Content-Type: $2; charset=UTF-8\r\n"
    print -n "Date: $(strftime "%a, %d %b %Y %H:%M:%S" $EPOCHSECONDS) GMT\r\n"
    print -n "Server: czhttpd\r\n"
    for i v in "$@[3,-1]"; do
        print -n "$i: $v\r\n"
    done
    print -n "\r\n"
}

function error_header() {
    case "$1" in
        (404)
            message="404 Not Found";;
        (501)
            message="Not Implemented";;
    esac

    return_header "$message" text/plain Content-Length ${#message}
    print "$message"
}
            
function html_template() {
cat <<EOF
<!DOCTYPE html>
<html>
<head>
<style type="text/css">
a {text-decoration: none;}
table { border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; border-collapse: collapse; margin: 4px; }
thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; }
thead th:nth-child(2) { text-align: right; padding-right: 12px; }
tbody td:nth-child(2) { text-align: right; padding-right: 12px; }
tbody td:first-child { padding-right: 30px; }
tbody tr:hover { background: rgba(0,0,0,0.3); color: #fff; cursor: pointer; }
</style>
<title>czhttpd</title>
</head>
<body>
<h1>Index of $1</h1>
<table padding=10>
    <thead>
    <tr>
        <th>Name</th>
        <tsize>
        <th>Size</th>
        </tsize>
        <th>Type</th>
    </tr>
    </thead>
    <tbody>
    $@[2,-1]
    </tbody>
</table>
</body>
</html>
EOF
}

function urlencode() {
    for i in ${(s::)1}; do
        case "$i" in
            ([-._~A-Za-z0-9])
                printf '%s' "$i";;
            (*)
                printf '%%%02x' "'$i";;
        esac
    done

    printf '\n'
}

function urldecode() {
    printf '%b\n' "${1:gs/%/\\x}"
}

function mime_type() {
    if [[ -f $1 ]]; then
        case $1 in
            (*.html)
                print "text/html";;
            (*)
                type=$(file --mime-type -bL $1)
                [[ ${type:h} == text ]] && { print "text/plain" && continue }
                print "${type#application/x-executable}";;
        esac
    elif [[ -d $1 ]]; then
        print "Directory"
    fi
}

function calc_size() {
    [[ -d "$1" ]] && { print "\-" && return }

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0
    
    size=$(stat -L +size $1)

    (( $size < $KB )) && { printf '%.1f%s\n' "${size}" "B" && return }
    (( $size < $MB )) && { printf '%.1f%s\n' "$((size/$KB))" "K" && return }
    (( $size < $GB )) && { printf '%.1f%s\n' "$((size/$MB))" "M" && return }
    (( $size > $GB )) && { printf '%.1f%s\n' "$((size/$GB))" "G" && return }
}
 
function list_dir() {
    local -a dir files
    cd "$1"

    [[ "${1%/}" != "${DOCROOT%/}" ]] && dir+="/../"

    for i in ./*(Nr); do
        [[ -d "$i" ]] && { dir+="${i}/" && continue }
        files+="$i"
    done

    for i in $dir $files; do
        print "<tr><td><a href=\"${i#*/}\">${i#*/}</a></td>"
        print "<td>$(calc_size $i)</td>"
        print "<td>$(mime_type $i)</td></tr>"
    done

    cd - 
}

function send_file() {
    local -a array

    stat -H array $1
    mimetype=$(mime_type $1)

    return_header "200 Ok" $mimetype Content-Length $array[size]
    cat $1 
}

function send_chunk() {
    printf '%x\r\n' "$(expr "x$1" : '.*' - 1)"
    printf '%s\r\n' "$1"
    printf '%x\r\n' "0"
    printf '\r\n'
}

function srv() {
    [[ $header[method] != "GET" ]] && { error_header 501; return 1 }

    pathname="${DOCROOT}${$(urldecode $header[url])%/}"
    if [[ -d "$pathname" ]]; then
        if [[ -f $pathname/index.html ]]; then
            send_file $pathname/index.html 
        else
            return_header "200 Ok" text/html Transfer-Encoding chunked
            send_chunk "$(html_template $pathname $(list_dir $pathname))"
        fi
    elif [[ -f "$pathname" ]]; then
        send_file $pathname
    else
        error_header 404
        return 1
    fi
}

function cleanup() {
    print "\nGoodbye!"

    for i in ${(SM)jobstates##<->}; do
        kill $i 2>/dev/null
    done

    logger "> Exiting czhttpd"
    exec {logfd}>&-; exec {fifofd}>&-
    rm $FIFO; ztcp -c; exit
}

function TRAPCHLD() {
    while read -t 0 -u $fifofd line; do
        logger "Exiting fork $line"
    done
}


# Main
trap "cleanup" INT KILL TERM

parse_args $*
if [[ $VERBOSE == 1 ]]; then
    if [[ $LOG == 1 ]]; then
        exec {logfd}>>$LOGFILE
    else
        exec {logfd}>&1
    fi
else
    exec {logfd}>/dev/null
fi

logger "> Initializing czhttpd"

http_listen

mkfifo $FIFO 2>/dev/null || error "Can not create $FIFO"
exec {fifofd}<>$FIFO


while :; do
    while (( ${#jobstates} >= $MAX_CONNECTIONS )); do
        zselect -r $fifofd && break
    done

    ztcp -a $listenfd

    logger "Incoming connection, forking..."
    ( trap "ztcp -c; exit" KILL TERM

    fd=$REPLY
    while :; do
        unset header && typeset -A header
        while read -r key value; do
            header[${key//:/}]="$value"
        done < <(parse_header)

        if [[ -z $header || header[Connection] == close ]]; then
            logger "Closing connection"
            RC=113; break
        fi

        logger "Serving $header[url]"
        srv >&$fd
    done

    ztcp -c

    # Mimic exit status since zsh does not have a posix compatible 'wait'
    print "$sysparams[pid]: ${RC:-0}" ) >&$fifofd &

    logger "Current forks: $jobstates"
    ztcp -c $REPLY
done

#!/usr/bin/zsh
# zsh web server

# Clear env
for z in ${(SM)$(export)#*=}; do
    case ${z%=} in
        (PWD|_|HOME)
            continue;;
        (*)
            unset ${z%=};;
    esac
done

export PATH=/bin:/usr/bin

# Load Modules
zmodload zsh/net/tcp
zmodload zsh/files
zmodload zsh/stat
zmodload zsh/datetime
zmodload zsh/system
zmodload zsh/zselect

# zsh options
unsetopt multibyte
unsetopt multios
setopt posix_jobs

# Declare variable types
integer logfd
integer errfd
integer fifofd

typeset -A MTYPES
typeset -a LOG_FORMAT

# Internal function variables that need global scope
typeset -A req_headers
typeset -a dotdir dotfiles dir files
typeset -a cgi_head cgi_body
typeset cgi_status_code

# Functions
function error() {
    print "[$(strftime "%a %d %b, %H:$M:%S" $EPOCHSECONDS)] Fatal Error: $*" >&2 >&$errfd

    exec {logfd}>&-
    rm $FIFO 2>/dev/null
    ztcp -c; exit 113
}

function log_f() {
    print "${(e@)LOG_FORMAT} $*" >&$logfd
}

function log_err() {
    print "${(e@)LOG_FORMAT} Error -> $*" >&$errfd
}

function timeout() {
    local pid1 pid2

    function TRAPCHLD() {
        kill $pid1 $pid2 2>/dev/null
    }

    $* &; pid1=$!
    sleep $CGI_TIMEOUT &; pid2=$!

    wait $pid1
    kill $pid2 2>/dev/null
}

function ip_addr() {
    local -a tcp_list
    local -a ip
    local i k v

    tcp_list=("${(f@)$(</proc/net/tcp)}")

    for i in $tcp_list[2,-1]; do
        if [[ $i[7,14] != 00000000 && $i[7,14] != 0100007F ]]; then
            for k v in "${(s..)i[7,14]}"; do
                ip+="0x${(L)k}${(L)v}"
            done

            break
        fi
    done

    printf "%d.%d.%d.%d\n" ${(Oa)ip[@]}
}

function help() {
<<EOF
Usage: czhttpd [OPTIONS] <file or dir>

czhttpd - cloud's zsh http server

Options
    -c :    Config file location (default: ~/.config/czhttpd/main.conf)
    -h :    Print this help message
    -v :    Redirect log messages to stdout

If no file or directory is given, czhttpd defaults to serving
the current directory.
EOF

exit
}

function parse_conf() {
    if [[ -f $1 ]]; then
        . $1 || print "Could not source config file $1"
    fi

    (( $hidden_files )) && setopt GLOB_DOTS

    if [[ -d $LOG_DIR ]]; then
        exec {errfd}>>$LOG_DIR/error.log
        exec {logfd}>>$LOG_DIR/access.log
    else
        print "Invalid log directory $LOG_DIR"
    fi

    [[ -n $MAX_CONN && $MAX_CONN != <-> ]] && error "Invalid integer for MAX_CONN in conf file $1"


}

function parse_args() {
    local -A opts
    local i

    zparseopts -K -D -A opts c: p: h v || error 2>/dev/null

    [[ -n ${(kM)opts:#-h} ]] && help

    [[ -n $opts[-c] && ! -f $opts[-c] ]] && error "Config file $opts[-c] does not exist"
    parse_conf ${opts[-c]:-~/.config/czhttpd/conf/main.conf}

    for i in ${(k)opts}; do
        case $i in
            ("-v")
                exec {errfd}>&1; exec {logfd}>&1;;
            ("-p")
                PORT=$opts[$i];;
        esac
    done

    log_f "> Initializing czhttpd"

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        DOCROOT="$1"
    else
        DOCROOT="$PWD"
    fi
}

function http_listen() {
    typeset -g listenfd

    if (( $PORT > 1024 )); then
        ztcp -l $PORT 2>/dev/null || error "Could not bind to port $PORT"
        print "Listening on $PORT"
        listenfd=$REPLY
    else
        error "Invalid port number, $PORT"
    fi
}

function parse_request() {
    unset req_headers; typeset -gA req_headers
    local method url querystr version key value line

    read -t $HTTP_TIMEOUT -r -u $fd line || return 1
    for method url version in ${(s. .)line%$'\r'}; do
        req_headers[method]="$method"
        req_headers[url]="${url%\?*}"
        req_headers[querystr]="${(M)url%\?*}"
        req_headers[version]="$version"
    done

    while read -t $HTTP_TIMEOUT -r -u $fd line; do
        [[ -n $line && $line != $'\r' ]] || break
        for key value in ${(s/: /)line%$'\r'}; do
            req_headers[${(L)key}]="$value"
        done
    done
}

function check_request() {
    case $req_headers[version] in
        ("HTTP/1.1")
            [[ -z $req_headers[host] ]] && { error_header 400; return 1 };;
        (*)
            error_header 505
            return 1;;
    esac

    case $req_headers[method] in
        ("HEAD"|"GET"|"POST")
            return 0;;
        (*)
            error_header 501
            return 1;;
    esac
}

function return_header() {
    local i

    print -n "HTTP/1.1 $1\r\n"

    if [[ $HTTP_KEEP_ALIVE == 0 ]]; then
        print -n "Connection: close\r\n"
    else
        print -n "Connection: ${req_headers[connection]:-keep-alive}\r\n"
    fi

    print -n "Date: $(export TZ=UTC && strftime "%a, %d %b %Y %H:%M:%S" $EPOCHSECONDS) GMT\r\n"
    print -n "Server: czhttpd\r\n"
    for i in "$@[2,-1]"; do
        print -n "$i\r\n"
    done
    print -n "\r\n"
}

function error_header() {
    local message
    local -a add_headers

    case "$1" in
        (301)
            message="301 Moved Permanently"
            add_headers+="Location: $2";;
        (400)
            message="400 Bad Request";;
        (403)
            message="403 Forbidden";;
        (404)
            message="404 Not Found";;
        (500)
            message="500 Internal Server Error";;
        (501)
            message="501 Not Implemented";;
        (505)
            message="505 HTTP Version Not Supported";;
    esac

    log_f "$message"
    return_header "$message" "Content-type: text/plain; charset=UTF-8" "Content-Length: ${#message}" $add_headers[@]
    print "$message"
}

function html_template() {
<<EOF
<!DOCTYPE html><html><head><style type="text/css"> a {text-decoration: none;} a:hover, a:focus { color: white; background: rgba(0,0,0,0.3); cursor: pointer; } h2 { margin-bottom: 10px } table { border-collapse: collapse; } thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; } thead th:nth-child(2) { text-align: right; padding-right: 12px; } tbody td:nth-child(2) { text-align: right; padding-right: 12px; } tbody td:first-child { padding-right: 30px; } div.list { background-color: #F5F5F5; border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; margin: 4px;} div.footer { font: 90% monospace; color: grey; font-style: italic; padding-left: 4px; }</style><title>czhttpd</title></head><body><h2>Index of $1</h2><div class=list><table><thead><tr><th>Name</th><th>Size</th><th>Type</th></tr></thead><tbody>$@[2,-1]</tbody></table></div><div class=footer>$SERVER_SOFTWARE</div></body></html>
EOF
}

function html_fragment() {
<<EOF
<tr><td><a href="${1#*/}">${1#*/}</a></td><td>$(calc_size $1)</td><td>$(mime_type $1)</td></tr>
EOF
}

function urldecode() {
    printf '%b\n' "${1:gs/%/\\x}"
}

function mime_type() {
    [[ -d "$1" ]] && { print "Directory"; return }

    local file_tail="${1:t}"
    if [[ -n $MTYPES[${file_tail#*.}] ]]; then
        print $MTYPES[${file_tail#*.}]
    else
        if which file >/dev/null; then
            mtype=$(file --mime-type -bL $1)

            case $mtype in
                (*"no read permission")
                    print "application/octet-stream";;
                ("text/"*)
                    print "text/plain";;
                (*)
                    print "${mtype#application/x-executable}";;
            esac
        else
            print ${MTYPES[default]:-application/octet-stream}
        fi
    fi
}

function calc_size() {
    [[ -d "$1" ]] && { print "\-"; return }

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0
    
    size=$(stat -L +size $1)

    (( $size < $KB )) && { printf '%.1f%s\n' "${size}" "B" && return }
    (( $size < $MB )) && { printf '%.1f%s\n' "$((size/$KB))" "K" && return }
    (( $size < $GB )) && { printf '%.1f%s\n' "$((size/$MB))" "M" && return }
    (( $size > $GB )) && { printf '%.1f%s\n' "$((size/$GB))" "G" && return }
}

function list_dir() {
    unset dir dotdir files dotfiles
    typeset -ga dir dotdir files dotfiles
    local i

    cd "$1" || return 1

    [[ "${1%/}" != "${DOCROOT%/}" ]] && dotdir+="$(html_fragment '/../')"

    for i in ./*(Nr); do
        if [[ $i == ./.* ]]; then
            [[ -d "$i" ]] && dotdir+="$(html_fragment $i/)"
            [[ -f "$i" ]] && dotfiles+="$(html_fragment $i)"
            continue
        elif [[ -d "$i" ]]; then
            dir+="$(html_fragment $i/)"
        else
            files+="$(html_fragment $i)"
        fi
    done

    cd -
}

function send_list() {
    local mtype="text/html"

    list_dir $1 || return 1

    { if ! filter_search; then
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Transfer-Encoding: chunked"
        send_chunk
        log_f "200"
    fi } < <(html_template $1 $dotdir $dotfiles $dir $files)
}

function send_file() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        <$1
    fi
}

function send_chunk() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local buff

        # Buffer output into 8K chunks using a pipe and sysread
        while sysread buff; do
            printf '%x\r\n' "${#buff}"
            printf '%s\r\n' "$buff"
        done

        printf '%x\r\n' "0"
        printf '\r\n'
    fi
}

function default_handler() {
    local -A file_array

    local mtype
    mtype=$(mime_type $1)

    stat -H file_array $1

    # Find a filter, e.g. to compress output, if not send raw file
    if ! filter_search $1; then
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Length: $file_array[size]"
        send_file $1
    fi

    log_f "200"
}

function filter_search() {
    local i

    for i in ${(Mk)functions#*_filter}; { $i $1 && return }

    return 1
}

function handler_search() {
    local i

    for i in ${(Mk)functions#*_handler}; do
        if [[ $i != "default_handler" ]]; then
            $i $1 && return
        fi
    done

    return 1
}

function srv() {
    pathname="${DOCROOT}$(urldecode $req_headers[url])"
    if [[ -f $pathname ]]; then
        [[ $options[globdots] == off && ${pathname:t} == .* ]] && { error_header 403; return }

        # Find a handler for $pathname (e.g. to handle cgi), if not use the default
        if ! handler_search $pathname; then
            default_handler $pathname
        fi
    elif [[ -d $pathname ]]; then
        [[ $FOLLOW_SYMLINKS == 0 && -h ${pathname%/} ]] && { error_header 403; return }

        if [[ -f $pathname/$INDEX_FILE ]]; then
            if ! handler_search $pathname/$INDEX_FILE; then
                default_handler $pathname/$INDEX_FILE
            fi
        else
            if [[ $pathname != $DOCROOT && $pathname[-1] != "/" ]]; then
                error_header 301 "http://$SERVER_ADDR:$PORT${pathname#$DOCROOT}/"
                return
            else
                send_list "$pathname" || { error_header 403; return }
            fi
        fi
    else
        error_header 404
        return
    fi
}

function cleanup() {
    for i in ${(SM)jobstates##<->}; do
        kill $i 2>/dev/null
    done

    log_f "> Exiting main"
    exec {logfd}>&-; exec {fifofd}>&-
    rm $FIFO; ztcp -c
}

function TRAPCHLD() {
    # Flush fifo data so we don't fill up the pipe (do we really care about the child's exit status?)
    while sysread -t 0 -i $fifofd -o 1 1>/dev/null; do
        continue
    done
}

# Main
trap "cleanup; exit" INT KILL TERM

readonly SERVER_NAME="$(ip_addr)"
readonly SERVER_ADDR="$SERVER_NAME"
readonly SERVER_SOFTWARE="czhttpd/$(printf '%.1f\n' "$((RANDOM/10000.0))")b"
readonly SERVER_PROTOCOL="HTTP/1.1"
readonly GATEWAY_INTERFACE="CGI/1.1"
LOG_FORMAT=( '[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)]'
             '[pid: $sysparams[pid]]'
             '$client_ip'
             '$req_headers[method]'
             '$req_headers[url]'
             '$req_headers[version]' )
readonly LOG_FORMAT


# By default discard logging output
exec {logfd}>/dev/null
exec {errfd}>/dev/null

# Parse cli options and config file
parse_args $*

# Set our default variables
log_f "MAXCONN: ${MAX_CONN:=12}"
log_f "PORT: ${PORT:=8080}"
log_f "HTTP_KEEP_ALIVE: ${HTTP_KEEP_ALIVE:=1}"
log_f "INDEX_FILE: ${INDEX_FILE:=index.html}"
log_f "HIDDEN_FILES: ${HIDDEN_FILES:=0}"
log_f "LOG_DIR: ${LOG_DIR:=~/.config/czhttpd/log}"
log_f "FIFO_DIR: ${FIFO_DIR:=/tmp}"

if [[ -z $MTYPES ]]; then
    MTYPES=( pdf       application/pdf
            gz        application/x-gzip
            tar.gz    application/x-tgz
            tgz       application/x-tgz
            tar       application/x-tar
            zip       application/zip
            gif       image/gif
            jpeg      image/jpeg
            jpg       image/jpeg
            png       image/png
            css       text/css
            html      text/html
            htm       text/html
            js        text/javascript
            sh        text/plain
            py        text/plain
            pl        text/plain
            log       text/plain
            conf      text/plain
            text      text/plain
            txt       text/plain
            default   application/octet-stream )
fi

http_listen

FIFO=$FIFO_DIR/czhttpd-$$.fifo
mkfifo $FIFO 2>/dev/null || error "Can not create fifo, $FIFO"
exec {fifofd}<>$FIFO

while :; do
    # Use select to block until a child writes to fifo on exit
    while (( ${#jobstates} >= $MAX_CONN )); do
        log_f "max connections hit, temporarily unable to fork"
        zselect -r $fifofd && break
    done

    ztcp -a $listenfd

    ( trap "ztcp -c; exit" KILL TERM; trap '' PIPE

    fd=$REPLY

    while read ip_line; do
        [[ $ip_line[3] == "I" ]] && { client_ip=${ip_line[(ws. .)3]}; break }
    done < <(ztcp -L)

    while :; do
        if parse_request && check_request; then
            srv 2>&1 >&$fd | sysread buff
            lstatus=$pipestatus[1]

            [[ -n $buff ]] && { log_err "${(M)buff##*[[:alnum:]]}"; unset buff }

            [[ $lstatus != 0 ]] && { log_err "broken socket, closing"; break }
            [[ $HTTP_KEEP_ALIVE == 0 || $req_headers[connection] == "close" ]] && break
        fi
    done

    ztcp -c
    print "0" >&$fifofd ) &

    ztcp -c $REPLY
done

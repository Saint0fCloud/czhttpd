#!/usr/local/bin/zsh
### czhttpd
# zsh web server
# Author: jsks
# Site: http://github.com/jsks/czhttpd.git
###

# Clear env
for z in ${(SM)$(export)#*=}; do
    case ${z%=} in
        (PWD|_|HOME)
            continue;;
        (*)
            unset ${z%=};;
    esac
done

export PATH=/sbin:/bin:/usr/bin:/usr/local/bin

# Load Modules
zmodload zsh/datetime
zmodload zsh/files
zmodload zsh/parameter
zmodload zsh/stat
zmodload zsh/system
zmodload zsh/net/tcp
zmodload zsh/zselect

### zsh options
# unset:
#   multibyte - to accurately get length of utf8 strings
#   glob_dots - prevent iterating through dot files automatically
#   err_return - set only within `srv` to handle errors at highest level
# set:
#   posix_jobs - for handling jobs in communicating parent<-child
#   bare_glob_qual - required for our patterns in `list_dir`
unsetopt multibyte glob_dots err_return multios
setopt posix_jobs bare_glob_qual local_options

# Declare variable types
integer logfd errfd fifofd

typeset -A MTYPES
typeset -a LOG_FORMAT

readonly SCRIPT="$0"
readonly ARGV="$*"

# Internal function variables that need global scope
typeset -A req_headers

#### Platform specific code
case $OSTYPE in
    (linux*)
        function ip_addr() {
            local -a tcp_list ip
            local i k v

            tcp_list=("${(f@)$(</proc/net/tcp)}")

            for i in $tcp_list[2,-1]; do
                if [[ $i[7,14] != 00000000 && $i[7,14] != 0100007F ]]; then
                    for k v in "${(s..)i[7,14]}"; do
                        ip+="0x${(L)k}${(L)v}"
                    done

                    break
                fi
            done

            printf "%d.%d.%d.%d\n" ${(Oa)ip[@]}
        };;
    (darwin*|*bsd*)
        function ip_addr() {
            local line

            while read line; do
                if [[ ${line[(w)1]} == "inet"  && ${line[(w)2]} != "127.0.0.1" ]]; then
                    print ${line[(w)2]}
                    return
                fi
            done < <(ifconfig)
        };;
    (*)
        function ip_addr() {
            print "127.0.0.1"
        };;
esac

# TODO: implement timeout
if zsystem supports flock; then
    function mklock() {
        zsystem flock -f LOCK $1
    }

    function rmlock() {
        zsystem flock -u LOCK
        unset LOCK
    }
else
    function mklock() {
        typeset -g LOCK=${1}.lock
        while ! mkdir $LOCK 2>/dev/null; do
            continue
        done
    }

    function rmlock() {
        rmdir $LOCK
        unset LOCK
    }
fi

# Functions
function error() {
    setopt multios
    print "[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)] Fatal Error: $*" >&2 >&$errfd

    cleanup 2>/dev/null
    exit 113
}

function log_f() {
    print "${(e@)LOG_FORMAT} $*" >&$logfd
}

function log_err() {
    print "${(e@)LOG_FORMAT} Error -> $*" >&$errfd
}

function timeout() {
    local pid1 pid2 pid_status

    function TRAPCHLD() {
        kill $pid1 $pid2 2>/dev/null
        return 1
    }

    ${(z)1} &; pid1=$!
    sleep $2 &; pid2=$!

    wait $pid1
    pid_status=$?
    kill $pid2 2>/dev/null

    return $pid_status
}

function help() {
<<EOF
Usage: czhttpd [OPTIONS] <file or dir>

czhttpd - cloud's zsh http server

Options
    -c :    Config file location (default: ~/.config/czhttpd/main.conf)
    -h :    Print this help message
    -p :    Port to bind to (default: 8080)
    -v :    Redirect log messages to stdout

If no file or directory is given, czhttpd defaults to serving
the current directory.
EOF

exit
}

function parse_conf() {
    local i

    if [[ -f $1 ]]; then
        . $1 || print "Could not source config file $1"
    fi

    if [[ ! -t $logfd || ! -t $errfd ]] && (( $LOG )); then
        if [[ -n $LOG_DIR ]]; then
            if [[ $LOG_DIR == "/dev/null" ]]; then
                exec {logfd}>/dev/null {errfd}>/dev/null
            elif [[ -d $LOG_DIR ]]; then
                exec {logfd}>>$LOG_DIR/access.log {errfd}>>$LOG_DIR/error.log
            else
                error "Invalid log directory $LOG_DIR"
            fi
        else
            print "Warning: LOG_DIR not set, output redirected to /dev/null"
            exec {logfd}>/dev/null {errfd}>/dev/null
        fi
    fi

    [[ -n $FIFO_DIR && ! -d $FIFO_DIR ]] && error "Invalid fifo directory $FIFO_DIR"

    for i in MAX_CONN HTTP_TIMEOUT; do
        if [[ -n ${(P)i} && ${(P)i} != <-> ]]; then
            error "Invalid integer for $i"
        fi
    done

    for i in HTTP_KEEP_ALIVE HIDDEN_FILES FOLLOW_SYMLINKS CACHE; do
        if [[ -n ${(P)i} && ${(P)i} != [01] ]]; then
            error "Invalid integer for $i"
        fi
    done
}

function parse_args() {
    local -A opts

    zparseopts -K -D -A opts c: p: h v || error 2>/dev/null

    [[ -n ${(kM)opts:#-h} ]] && help
    [[ -n ${(kM)opts:#-v} ]] && exec {errfd}>&1 {logfd}>&1
    [[ -n $opts[-c] && ! -f $opts[-c] ]] && error "Config file $opts[-c] does not exist"
    parse_conf ${opts[-c]:-~/.config/czhttpd/conf/main.conf}
    [[ -n $opts[-p] ]] && PORT=$opts[-p]

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        DOCROOT="$1"
    else
        DOCROOT="$PWD"
    fi

    log_f "> Initialized czhttpd"
}

function http_listen() {
    typeset -g listenfd

    if (( $PORT > 1024 )); then
        if [[ $PORT != ${$(ztcp -L)[(w)4]} || -z $listenfd ]]; then
            ztcp -c
            ztcp -l $PORT 2>/dev/null || error "Could not bind to port $PORT"
            print "Listening on $PORT"
            listenfd=$REPLY
        fi
    else
        error "Invalid port number, $PORT"
    fi
}

function parse_request() {
    unset req_headers; typeset -gA req_headers
    local method url querystr version key value line

    read -t $HTTP_TIMEOUT -r -u $fd line || return 1
    for method url version in ${(s. .)line%$'\r'}; do
        req_headers[method]="$method"
        req_headers[url]="${url%\?*}"
        req_headers[querystr]="${(M)url%\?*}"
        req_headers[version]="$version"
    done

    while read -t $HTTP_TIMEOUT -r -u $fd line; do
        [[ -n $line && $line != $'\r' ]] || break
        for key value in ${(s/: /)line%$'\r'}; do
            req_headers[${(L)key}]="$value"
        done
    done
}

function check_request() {
    [[ -z $req_headers ]] && return 1

    case $req_headers[version] in
        ("HTTP/1.1")
            [[ -z $req_headers[host] ]] && { error_header 400; return 1 };;
        (*)
            error_header 505
            return 1;;
    esac

    case $req_headers[method] in
        ("HEAD"|"GET"|"POST")
            return 0;;
        (*)
            error_header 501
            return 1;;
    esac
}

function return_header() {
    local i

    print -n "HTTP/1.1 $1\r\n"

    if [[ $HTTP_KEEP_ALIVE == 0 ]]; then
        print -n "Connection: close\r\n"
    else
        print -n "Connection: ${req_headers[connection]:-keep-alive}\r\n"
    fi

    print -n "Date: $(export TZ=UTC && strftime "%a, %d %b %Y %H:%M:%S" $EPOCHSECONDS) GMT\r\n"
    print -n "Server: czhttpd\r\n"
    for i in "$@[2,-1]"; do
        print -n "$i\r\n"
    done
    print -n "\r\n"
}

function error_header() {
    local message
    local -a add_headers

    case "$1" in
        (301)
            message="301 Moved Permanently"
            add_headers+="Location: $2";;
        (400)
            message="400 Bad Request";;
        (403)
            message="403 Forbidden";;
        (404)
            message="404 Not Found";;
        (500)
            message="500 Internal Server Error";;
        (501)
            message="501 Not Implemented";;
        (505)
            message="505 HTTP Version Not Supported";;
    esac

    log_f "$message"
    return_header "$message" "Content-type: text/plain; charset=UTF-8" "Content-Length: ${#message}" $add_headers[@]
    print "$message"
}

function html_template() {
    print "<!DOCTYPE html><html><head><style type="text/css"> a {text-decoration: none;} a:hover, a:focus { color: white; background: rgba(0,0,0,0.3); cursor: pointer; } h2 { margin-bottom: 10px } table { border-collapse: collapse; } thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; } thead th:nth-child(2) { text-align: left; padding-right: 12px; } tbody td:nth-child(2) { text-align: right; padding-right: 12px; } tbody td:first-child { padding-right: 30px; } div.list { background-color: #F5F5F5; border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; margin: 4px;} div.footer { font: 90% monospace; color: grey; font-style: italic; padding-left: 4px; }</style><title>czhttpd</title></head><body><h2>Index of $1</h2><div class=list><table><thead><tr><th>Name</th><th>Last-Modified</th><th>Size</th><th>Type</th></tr></thead><tbody>$@[2,-1]</tbody></table></div><div class=footer>$SERVER_SOFTWARE</div></body></html>"
}

function html_fragment() {
    index+="<tr><td><a href=\"${1#*/}\">${1#*/}</a></td><td>$(mtime $1)</td><td>$(calc_size $1)</td><td>$(mime_type $1)</td></tr>"
}

function urldecode() {
    printf '%b\n' "${1:gs/%/\\x}"
}

function mime_type() {
    [[ -h "${1%/}" ]] && print -n "symbolic link->"

    [[ -d "$1" ]] && { print "Directory"; return }
    local file_tail mtype

    file_tail="${(L)1:t}"
    if (( $+MTYPES[${file_tail#*.}] )); then
        print $MTYPES[${file_tail#*.}]
    else
        if which file >/dev/null; then
            mtype=$(file --mime-type -bL $1)

            case $mtype in
                (*"no read permission")
                    print "application/octet-stream";;
                ("text/"*)
                    print "text/plain";;
                (*)
                    print "${${mtype#application/x-executable}:-application/octet-stream}";;
            esac
        else
            print ${MTYPES[default]:-application/octet-stream}
        fi
    fi
}

function calc_size() {
    [[ -d "$1" ]] && { print "\-"; return }
    local KB MB GB size

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0
    
    size=$(stat -L +size $1)

    (( $size < $KB )) && { printf '%.1f%s\n' "${size}" "B" && return }
    (( $size < $MB )) && { printf '%.1f%s\n' "$((size/$KB))" "K" && return }
    (( $size < $GB )) && { printf '%.1f%s\n' "$((size/$MB))" "M" && return }
    (( $size > $GB )) && { printf '%.1f%s\n' "$((size/$GB))" "G" && return }
}

function mtime() {
    stat -L -F "%d-%b-%Y %H:%M" +mtime $1 2>/dev/null || print "\-"
}

function build_index() {
    local -a index
    local i

    cd "$1"

    [[ "${1%/}" != "${DOCROOT%/}" ]] && html_fragment '/../'

    if (( $HIDDEN_FILES )); then
        for i in ./.*(-/NrT) ./.*(-.Nr); do
            html_fragment "$i"
        done
    fi

    for i in ./*(-/NrT) ./*(-.Nr); do
        html_fragment "$i"
    done

    cd -

    html_template "$1" $index
}

function spawn_cache_worker() {
    setopt noerrreturn

    mkdir $CACHE_DIR 2>/dev/null
    if ! whence fswatch >/dev/null; then
        log_err "Can't find fswatch"
        return 1
    fi

    (trap "worker_cleanup; exit" KILL TERM
    setopt globdots

    function worker_cleanup() {
        kill -9 $coproc_pid 2>/dev/null
        for i in $CACHE_DIR/*(N); rm -fr $i
    }

    coproc fswatch -r $DOCROOT
    local coproc_pid=$!

    while read -p line; do
        cache_file="${CACHE_DIR}/${line:h:gs/\//}.html"
        [[ ! -f $cache_file ]] && { unset cache_file; continue }

        mklock $cache_file

        { rm $cache_file 2>/dev/null } always { rmlock }
        unset cache_file
    done) &
}

function send_file() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        <$1
    fi
}

function send_chunk() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local buff

        # Buffer output into 8K chunks using a pipe and sysread
        while sysread buff; do
            printf '%x\r\n' "${#buff}"
            printf '%s\r\n' "$buff"
        done

        printf '%x\r\n' "0"
        printf '\r\n'
    fi
}

function __send() {
    if [[ -n $1 ]]; then
        return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Length: $fsize"
        send_file $1
    else
        return_header "200 Ok" "Content-type: text/html; charset=UTF-8" "Transfer-Encoding: chunked"
        send_chunk
    fi

    log_f "200"
}

function __handler() {
    if [[ -f $1 ]]; then
        [[ -z $mtype ]] && local mtype=$(mime_type $1)
        [[ -z $fsize ]] && local fsize=$(stat -L +size $1)

        send $1
    else
        if (( $CACHE )); then
            local cache_file="${CACHE_DIR}/${1//\//}.html"
            : >> $cache_file
            mklock $cache_file

            [[ ! -s $cache_file ]] && build_index $1 > $cache_file

            cd $CACHE_DIR
            { handler ${cache_file:t} } always { cd -; rmlock }
        else
            send < <(build_index $1)
        fi
    fi
}

function __srv() {
    setopt err_return
    local pathname="${DOCROOT}$(urldecode ${1:-$req_headers[url]})"

    [[ $HIDDEN_FILES != "1" && ${pathname:t} == .* ]] && { error_header 403; return }
    [[ $FOLLOW_SYMLINKS != "1" && -h ${pathname%/} ]] && { error_header 403; return }

    { if [[ -f $pathname ]]; then
        handler $pathname
    elif [[ -d $pathname ]]; then
        if [[ $pathname != $DOCROOT && $pathname[-1] != "/" ]]; then
            error_header 301 "http://$SERVER_ADDR:$PORT${pathname#$DOCROOT}/"
        elif [[ -f $pathname/$INDEX_FILE ]]; then
            handler $pathname/$INDEX_FILE
        else
            if [[ -r "$pathname" && -x "$pathname" ]]; then
                handler "$pathname"
            else
                error_header 403
            fi
        fi
    else
        error_header 404
    fi } always { [[ $? != 0 ]] && error_header 500 }
}

function reload_state() {
    (( $CACHE )) && kill -15 $CACHE_WORKER_PID 2>/dev/null

    OLD_FIFO=$FIFO
    OLD_FIFO_FD=$fifofd
    exec {logfd}>&- {errfd}>&-
    czhttpd_init ${=ARGV}

    if [[ $OLD_FIFO != $FIFO ]]; then
        rm $OLD_FIFO
        OLD_PIDS=(${(SM)jobstates##<->})
        if [[ -n $OLD_PIDS ]]; then
            ( while sysread -i $OLD_FIFO_FD -o $fifofd; do
                for i in $OLD_PIDS; do
                    ! kill -0 $i 2>/dev/null && OLD_PIDS=(${OLD_PIDS[@]#i})
                done
                [[ -z $OLD_PIDS ]] && break
            done
            print "0" >&$fifofd ) &
        fi
    fi

    exec {OLD_FIFO_FD}>&-
    unset OLD_FIFO OLD_FIFO_FD OLD_PIDS
}

function cleanup() {
    setopt noerrreturn
    kill -15 ${(SM)jobstates##<->} 2>/dev/null

    log_f "> Exiting main"
    exec {logfd}>&- {errfd}>&- {fifofd}>&-
    rm -rf $FIFO $CACHE_DIR
    ztcp -c
}

#### Main
function czhttpd_init() {
    LOG_FORMAT=( '[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)]'
                 '[pid: ${PID:-$sysparams[pid]}]'
                 '$client_ip'
                 '$req_headers[method]'
                 '$req_headers[url]'
                 '$req_headers[version]' )

    # Parse cli options and config file
    parse_args ${=ARGV}

    # Default callback functions, allows modules to override how we handle requests
    # Can't be simple aliases since shell won't find the cmd
    ! typeset -f send >/dev/null && function send() { __send $* }
    ! typeset -f handler >/dev/null && function handler() { __handler $* }
    ! typeset -f srv >/dev/null && function srv() { __srv $* }

    # Set our default variables
    log_f "MAXCONN: ${MAX_CONN:=12}"
    log_f "PORT: ${PORT:=8080}"
    log_f "IP_REDIRECT: ${IP_REDIRECT:=$(ip_addr)}"
    log_f "IP_ACCEPT: ${IP_ACCEPT:=[0-9*].[0-9*].[0-9*].[0-9*]}"
    log_f "HTTP_KEEP_ALIVE: ${HTTP_KEEP_ALIVE:=1}"
    log_f "HTTP_TIMEOUT: ${HTTP_TIMEOUT:=30}"
    log_f "INDEX_FILE: ${INDEX_FILE:=index.html}"
    log_f "HIDDEN_FILES: ${HIDDEN_FILES:=0}"
    log_f "FOLLOW_SYMLINKS: ${FOLLOW_SYMLINKS:=0}"
    log_f "CACHE: ${CACHE:=0}"
    log_f "CACHE_DIR: ${CACHE_DIR:=/tmp/.czhttpd-$$/}"
    log_f "LOG_DIR: ${LOG_DIR:=/dev/null}"
    log_f "FIFO_DIR: ${FIFO_DIR:=/tmp}"

    readonly SERVER_NAME="$IP_REDIRECT"
    readonly SERVER_ADDR="$SERVER_NAME"
    readonly SERVER_SOFTWARE="czhttpd/$(printf '%.1f\n' "$((RANDOM/10000.0))")b"
    readonly SERVER_PROTOCOL="HTTP/1.1"
    readonly GATEWAY_INTERFACE="CGI/1.1"

    if [[ -z $MTYPES ]]; then
        MTYPES=( pdf       application/pdf
                 gz        application/x-gzip
                 tar.gz    application/x-tgz
                 tgz       application/x-tgz
                 tar       application/x-tar
                 zip       application/zip
                 gif       image/gif
                 jpeg      image/jpeg
                 jpg       image/jpeg
                 png       image/png
                 css       text/css
                 html      text/html
                 htm       text/html
                 js        text/javascript
                 sh        text/plain
                 py        text/plain
                 pl        text/plain
                 log       text/plain
                 conf      text/plain
                 text      text/plain
                 txt       text/plain
                 default   application/octet-stream )
    fi

    # For communication with our child processes
    FIFO=$FIFO_DIR/czhttpd-$$.fifo
    [[ ! -p $FIFO ]] && { mkfifo $FIFO || error "Can not create fifo, $FIFO" }
    exec {fifofd}<>$FIFO

    # For monitoring when our cache becomes invalid
    if (( $CACHE )); then
        spawn_cache_worker || error "Failed to initialise cache_worker"
        CACHE_WORKER_PID=$!
    fi

    return 0
}

function czhttpd_main() {
    # Run this function as a trap so that we trigger a flush
    # when ${#jobstates} < $MAX_CONN
    function TRAPCHLD() {
        while sysread -t 0 -i $fifofd -o 1 1>/dev/null; do
            continue
        done
    }

    function TRAPHUP() {
        log_f "Reloading config..."
        reload_state

        # Must replace process with exec, otherwise interrupting
        # ztcp -a will crash czhttpd.
        exec czhttpd_main
    }

    function TRAPUSR1() {
        log_f "Reloading program..."
        local timer_pid

        () { exec {logfd}>&- {errfd}>&- {fifofd}>&-; source ./$SCRIPT ${=ARGV} } &!

        { sleep 300; kill -15 $$ } &
        timer_pid=$!
        wait ${jobstates//([^[:digit:]]|$timer_pid|$CACHE_WORKER_PID)/} 2>/dev/null

        cleanup 2>/dev/null; exit
    }

    trap "cleanup 2>/dev/null; exit" INT KILL TERM
    http_listen

    while :; do
        # Use select to block until a child writes to fifo on exit
        while (( ${#jobstates} >= $MAX_CONN + $CACHE )); do
            log_f "max connections hit, temporarily unable to fork"
            zselect -r $fifofd && break
        done

        ztcp -a $listenfd

        ( trap "child_cleanup" KILL TERM EXIT; trap '' PIPE; trap - HUP
        function child_cleanup() { ztcp -c; print "0" >&$fifofd; exit }

        fd=$REPLY
        PID=$sysparams[pid]

        while read ip_line; do
            [[ $ip_line[3] == "I" ]] && { local client_ip=${ip_line[(w)3]}; break }
        done < <(ztcp -L)

        if [[ $client_ip =~ [^$IP_ACCEPT] && $client_ip != "0.0.0.0" ]]; then
            log_f "disconnected client matching filter $IP_ACCEPT"
            exit
        fi

        while parse_request && check_request; do
            srv 2>&1 >&$fd | sysread buff
            lstatus=$pipestatus[1]

            [[ -n $buff ]] && { log_err "${(f)buff}"; unset buff }

            [[ $lstatus != 0 ]] && { log_err "closing connection"; break}
            [[ $HTTP_KEEP_ALIVE == 0 || $req_headers[connection] == "close" ]] && break
        done ) &

        ztcp -c $REPLY
    done
}

czhttpd_init && czhttpd_main

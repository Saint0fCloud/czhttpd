#!/usr/bin/zsh
# zsh web server

# Clear env
for z in ${(SM)$(export)#*=}; do
    case ${z%=} in
        (PWD|_|HOME)
            continue;;
        (*)
            unset ${z%=};;
    esac
done

export PATH=/bin:/usr/bin

# Load Modules
zmodload zsh/net/tcp
zmodload zsh/files
zmodload zsh/stat
zmodload zsh/datetime
zmodload zsh/system
zmodload zsh/zselect

# zsh options
unsetopt multibyte
setopt posix_jobs

# Declare variable types
integer logfd
integer fifofd

# Mutable global variables
typeset -A VARS
VARS=( max_conn             "12"
       port                 "8080"
       http_keep_alive      "1"
       http_timeout         "30"
       follow_symlinks      "1"
       index_file           "index.html"
       compression          "0"
       compression_types     "text/html,text/css,text/javascript"
       compression_level    "6"
       compression_min_size "1000"
       cgi_extensions       ""
       cgi_timeout          "300"
       hidden_files         "0"
       log_file             "/dev/null"
       fifo_dir             "/tmp" )

# Readonly vars, initialise later
typeset -A RVARS

# Mimetypes
typeset -A MTYPES
MTYPES=( pdf       application/pdf
         gz        application/x-gzip
         tar.gz    application/x-tgz
         tgz       application/x-tgz
         tar       application/x-tar
         zip       application/zip
         gif       image/gif
         jpeg      image/jpeg
         jpg       image/jpeg
         png       image/png
         css       text/css
         html      text/html
         htm       text/html
         js        text/javascript
         sh        text/plain
         py        text/plain
         pl        text/plain
         log       text/plain
         conf      text/plain
         text      text/plain
         txt       text/plain
         default   application/octet-stream )

# Internal function variables that need global scope
typeset -A req_headers
typeset -a dotdir dotfiles dir files
typeset -a cgi_head cgi_body
typeset cgi_status_code

# Functions
function error() {
    print "Error: $*" >&2 >&$logfd

    exec {logfd}>&-
    rm $RVARS[fifo] 2>/dev/null
    ztcp -c; exit 113
}

function warn() {
    print "Warning: $*"
}

function logger() {
    print "[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)] $*" >&$logfd
}

function logger_child() {
    print "[$(strftime "%a %d %b, %H:%M:%S" $EPOCHSECONDS)] [pid: $sysparams[pid]] (client $client_ip): $req_headers[method] $req_headers[url] $req_headers[version] $*" >&$logfd
}

function timeout() {
    local pid1 pid2

    function TRAPCHLD() {
        kill $pid1 $pid2 2>/dev/null
    }

    $* &; pid1=$!
    sleep $VARS[cgi_timeout] &; pid2=$!

    wait $pid1
    kill $pid2 2>/dev/null
}

function ip_addr() {
    local -a tcp_list
    local -a ip

    tcp_list=("${(f@)$(</proc/net/tcp)}")

    for i v in "${(s..)tcp_list[-1][7,14]}"; do
        ip+="0x${(L)i}${(L)v}"
    done

    printf "%d.%d.%d.%d\n" ${(Oa)ip[@]}
}

function help() {
<<EOF
Usage: czhttpd [OPTIONS] <file or dir>

czhttpd - cloud's zsh http server

Configuration Options
    -C :    Config file location (default: ~/.config/czhttpd/czhttpd.conf)

Connection Options
    -c :    Force connection: close for all HTTP/1.1 response headers
    -m :    Max number of connections to accept (default: 12)
    -p :    Port to bind to (default: 8080)
    -t :    Connection timeout in seconds (default: 30)

File Options
    -a :    Display hidden files in directories
    -i :    Specify index file (default: index.html)
    -s :    Allow czhttpd to follow symlinks
    -x :    Comma delimited list of file extensions to treat as
            CGI scripts
    -z :    Enable gzip compression for text/{html,js,css}. An
            optional comma delimited list of file mimetypes can
            be specified for additional file types to compress.

Output Options
    -l :    Enable logging to existing file
    -v :    Print log messages to stdout
    -h :    Print this help message

If no file or directory is given, czhttpd defaults to serving
the current directory.
EOF

exit
}

function parse_conf() {
    local -i conf

    if [[ -f $1 ]]; then
        exec {conf}<$1

        while read -u $conf line; do
            [[ $line[1] == "#" ]] && continue

            if [[ $line[(ws. .)1] == "source" && -f ${line[(ws. .)2]:s/\~/$HOME/} ]]; then
                parse_conf ${line[(ws. .)2]:s/\~/$HOME/}
            else
                for k v in ${(s.=.)line:gs/\"//}; do
                    [[ $k == ${(kM)VARS:#$k} || $k == "mime_types" ]] || break

                    case $k in
                        (max_conn|http_keep_alive|http_timeout|follow_symlinks|compression|compression_min_size|cgi_timeout|hidden_files)
                            if [[ $v != <-> ]]; then
                                warn "Error setting $k from config file, not a valid integer."
                            else
                                VARS[$k]=$v
                            fi;;
                        (index_file|cgi_extensions)
                            VARS[$k]=$v;;
                        (compression_types)
                            VARS[$k]+=",$v";;
                        (fifo_dir)
                            if [[ -d $v ]]; then
                                VARS[$k]=$v
                            else
                                warn "Error setting $k from config file, not a valid directory."
                            fi;;
                        (port)
                            if [[ $v != <-> ]] || (( $v < 1024 )); then
                                warn "Error setting $k from config file, not a valid port number."
                            else
                                VARS[$k]=$v
                            fi;;
                        (compression_level)
                            if [[ $v != <-> ]] || (( $v > 9 || $v < 1 )); then
                                warn "Error setting $k from config file, not a valid compression level."
                            else
                                VARS[$k]=$v
                            fi;;
                        (log_file)
                            if [[ ! -f ${v:s/\~\//$HOME\//} ]]; then
                                warn "Error setting $k from config file, not a valid log file."
                            elif [[ $v != "/dev/null" ]]; then
                                exec {logfd}>>${v:s/\~\//$HOME\//}
                            fi;;
                        (mime_types)
                            unset MTYPES; typeset -gA MTYPES

                            if [[ $v[1] == "(" ]]; then
                                while :; do
                                    for i j in ${(ws. .)line#*\(}; do
                                        MTYPES[${i%\)*}]=${j%\)*}

                                        [[ -n ${i[(r)\)]} || -n ${j[(r)\)]} ]] && break 2
                                    done

                                    read -u $conf line || break
                                done
                            fi;;
                    esac
                done
            fi
        done
    fi
    exec {conf}>&-
}

function parse_args() {
    local -A opts

    zparseopts -K -D -A opts C: i: l: m: p: t: x: z:: a c h s v || error 2>/dev/null

    [[ -n $opts[-C] && ! -f $opts[-C] ]] && error "Config file $opts[-C] does not exist"
    parse_conf ${opts[-C]:-~/.config/czhttpd/main.conf}

    [[ -n ${(kM)opts:#-h} ]] && help
    [[ -n ${(k)opts[-l]} && -n ${(k)opts[-v]} ]] && error "Can not output to both stdout and logfile"

    for i in ${(k)opts}; do
        case $i in
            (-a)
                VARS[hidden_files]=1
                setopt GLOB_DOTS;;
            (-c)
                VARS[http_keep_alive]=0;;
            (-i)
                VARS[index_file]=$opts[$i];;
            (-l)
                [[ ! -f $opts[$i] ]] && error "File $opts[$i] does not exist"
                exec {logfd}>>$opts[$i];;
            (-m)
                [[ $opts[$i] != <-> ]] && error "$opts[$i] is not a valid integer"
                VARS[max_conn]=$opts[$i];;
            (-p)
                if [[ $opts[$i] != <-> ]]; then
                    error "$opts[$i] is not a valid integer"
                else
                    (( $opts[$i] < 1024 )) && error "$opts[$i] is not a valid port number"
                fi
                VARS[port]=$opts[$i];;
            (-s)
                VARS[follow_symlinks]=1;;
            (-t)
                [[ $opts[$i] != <-> ]] && error "$opts[$i] is not a valid integer"
                VARS[http_timeout]=$opts[$i];;
            (-v)
                exec {logfd}>&1 2>/dev/null;;
            (-x)
                VARS[cgi_extensions]+="$opts[$i]";;
            (-z)
                VARS[compression_types]+=",$opts[$i]"
                VARS[compression]=1;;
        esac
    done

    logger "> Initializing czhttpd"

    if [[ -n $1 ]]; then
        [[ -e $1 ]] || error "$1 is not a valid directory or file."
        RVARS[docroot]="$1"
    else
        RVARS[docroot]="$PWD"
    fi
}

function http_listen() {
    typeset -g listenfd

    ztcp -l $VARS[port] 2>/dev/null || error "Could not bind to port $VARS[port]"
    print "Listening on $VARS[port]"
    listenfd=$REPLY
}

function parse_request() {
    unset req_headers; typeset -gA req_headers

    read -t $VARS[http_timeout]  -r -u $fd line || return 1
    for method url version in ${(s. .)line%$'\r'}; do
        req_headers[method]="$method"
        req_headers[url]="${url%\?*}"
        req_headers[querystr]="${(M)url%\?*}"
        req_headers[version]="$version"
    done

    while read -t $VARS[http_timeout] -r -u $fd line; do
        [[ -n $line && $line != $'\r' ]] || break
        for key value in ${(s/: /)line%$'\r'}; do
            req_headers[${(L)key}]="$value"
        done
    done
}

function check_request() {
    case $req_headers[version] in
        ("HTTP/1.1")
            [[ -z $req_headers[host] ]] && { error_header 400; return 1 };;
        ("HTTP/1.0")
            continue;;
        (*)
            error_header 505
            return 1;;
    esac

    case $req_headers[method] in
        ("HEAD"|"GET"|"POST")
            return 0;;
        (*)
            error_header 501
            return 1;;
    esac
}

function return_header() {
    print -n "HTTP/1.1 $1\r\n"

    if [[ $VARS[http_keep_alive] == 0 || $req_headers[version] != "HTTP/1.1" ]]; then
        print -n "Connection: close\r\n"
    else
        print -n "Connection: ${req_headers[connection]:-keep-alive}\r\n"
    fi

    print -n "Date: $(export TZ=UTC && strftime "%a, %d %b %Y %H:%M:%S" $EPOCHSECONDS) GMT\r\n"
    print -n "Server: czhttpd\r\n"
    for i in "$@[2,-1]"; do
        print -n "$i\r\n"
    done
    print -n "\r\n"
}

function error_header() {
    local message
    local -a add_headers

    case "$1" in
        (301)
            message="301 Moved Permanently"
            add_headers+="Location: $2";;
        (400)
            message="400 Bad Request";;
        (403)
            message="403 Forbidden";;
        (404)
            message="404 Not Found";;
        (500)
            message="500 Internal Server Error";;
        (501)
            message="501 Not Implemented";;
        (505)
            message="505 HTTP Version Not Supported";;
    esac

    logger_child "$message"
    return_header "$message" "Content-type: text/plain; charset=UTF-8" "Content-Length: ${#message}" $add_headers[@]
    print "$message"
}

function html_template() {
<<EOF
<!DOCTYPE html>
<html>
<head>
<style type="text/css">
a {text-decoration: none;}
a:hover, a:focus { color: white; background: rgba(0,0,0,0.3); cursor: pointer; }
h2 { margin-bottom: 10px }
table { border-collapse: collapse; }
thead th { padding-top: 4px; padding-bottom: 6px; text-align: left; }
thead th:nth-child(2) { text-align: right; padding-right: 12px; }
tbody td:nth-child(2) { text-align: right; padding-right: 12px; }
tbody td:first-child { padding-right: 30px; }
div.list { background-color: #F5F5F5; border-top: 1px solid black; border-bottom: 1px solid black; font: 90% monospace; margin: 4px;}
div.footer { font: 90% monospace; color: grey; font-style: italic; padding-left: 4px; }
</style>
<title>czhttpd</title>
</head>
<body>
<h2>Index of $1</h2>
<div class=list>
    <table>
        <thead>
        <tr>
            <th>Name</th>
            <th>Size</th>
            <th>Type</th>
        </tr>
        </thead>
        <tbody>
        $@[2,-1]
        </tbody>
    </table>
</div>
<div class=footer>$RVARS[server_software]</div>
</body>
</html>
EOF
}

function html_fragment() {
<<EOF
<tr><td><a href="${1#*/}">${1#*/}</a></td>
<td>$(calc_size $1)</td>
<td>$(mime_type $1)</td></tr>
EOF
}

function urlencode() {
    for i in ${(s::)1}; do
        case "$i" in
            ([-._~A-Za-z0-9])
                printf '%s' "$i";;
            (*)
                printf '%%%02x' "'$i";;
        esac
    done

    printf '\n'
}

function urldecode() {
    printf '%b\n' "${1:gs/%/\\x}"
}

function mime_type() {
    [[ -d "$1" ]] && { print "Directory"; return }

    local file_tail="${1:t}"
    if [[ -n $MTYPES[${file_tail#*.}] ]]; then
        print $MTYPES[${file_tail#*.}]
    else
        if which file >/dev/null; then
            mtype=$(file --mime-type -bL $1)

            case $mtype in
                (*"no read permission")
                    print "application/octet-stream";;
                ("text/"*)
                    print "text/plain";;
                (*)
                    print "${mtype#application/x-executable}";;
            esac
        else
            print ${MTYPES[default]:-application/octet-stream}
        fi
    fi
}

function calc_size() {
    [[ -d "$1" ]] && { print "\-"; return }

    KB=1024.0
    MB=1048576.0
    GB=1073741824.0
    
    size=$(stat -L +size $1)

    (( $size < $KB )) && { printf '%.1f%s\n' "${size}" "B" && return }
    (( $size < $MB )) && { printf '%.1f%s\n' "$((size/$KB))" "K" && return }
    (( $size < $GB )) && { printf '%.1f%s\n' "$((size/$MB))" "M" && return }
    (( $size > $GB )) && { printf '%.1f%s\n' "$((size/$GB))" "G" && return }
}

function list_dir() {
    unset dir dotdir files dotfiles
    typeset -ga dir dotdir files dotfiles

    cd "$1" || return 1

    [[ "${1%/}" != "${RVARS[docroot]%/}" ]] && dotdir+="$(html_fragment '/../')"

    for i in ./*(Nr); do
        if [[ $i == ./.* ]]; then
            [[ -d "$i" ]] && dotdir+="$(html_fragment $i/)"
            [[ -f "$i" ]] && dotfiles+="$(html_fragment $i)"
            continue
        elif [[ -d "$i" ]]; then
            dir+="$(html_fragment $i/)"
        else
            files+="$(html_fragment $i)"
        fi
    done

    cd -
}

function check_if_compression() {
    [[ $VARS[compression] == 0 ]] && return 1
    [[ -z ${(SM)req_headers[accept-encoding]#gzip} ]] && return 1

    if [[ -f $1 ]]; then
        for i in ${(s.,.)VARS[compression_types]}; [[ $mtype == $i ]] && break

        if [[ $? != 0 ]] || (( $file_array[size] < $VARS[compression_min_size] )); then
            return 1
        fi
    fi

    return 0
}

function send_list() {
    local -a resp_headers

    list_dir $1 || return 1

    resp_headers=("200 Ok" "Content-type: text/html; charset=UTF-8" "Transfer-Encoding: chunked")

    if check_if_compression; then
        resp_headers+=("Content-Encoding: gzip")

        return_header $resp_headers[@]
        if [[ $req_headers[method] != "HEAD" ]]; then
            html_template $1 $dotdir $dotfiles $dir $files | gzip -$GZIP_LEVEL -c | send_chunk
        fi
    else
        return_header $resp_headers[@]
        if [[ $req_headers[method] != "HEAD" ]]; then
            html_template $1 $dotdir $dotfiles $dir $files | send_chunk
        fi
    fi
}

function send_compressed_file() {
    return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Encoding: gzip" "Transfer-Encoding: chunked"

    gzip -$VARS[compression_level] -c $1 | send_chunk
}

function send_raw_file() {
    return_header "200 Ok" "Content-type: $mtype; charset=UTF-8" "Content-Length: $file_array[size]"

    if [[ $req_headers[method] != "HEAD" ]]; then
        <$1
    fi
}

function send_chunk() {
    if [[ $req_headers[method] != "HEAD" ]]; then
        local buff

        # Buffer output into 8K chunks using a pipe and sysread
        while sysread buff; do
            printf '%x\r\n' "$(print ${#buff})"
            printf '%s\r\n' "$buff"
        done

        printf '%x\r\n' "0"
        printf '\r\n'
    fi
}

function check_if_cgi() {
    [[ -z $VARS[cgi_extensions] ]] && return 1

    for i in ${(s.,.)VARS[cgi_extensions]}; [[ ${1##*.} == $i ]] && break

    [[ $? != 0 || ! -x $1 ]] && return 1

    return 0
}

function exec_cgi() {
    unset cgi_head cgi_status_code
    typeset -ga cgi_head
    typeset -g cgi_status_code

    local cmd pid

    local -x CONTENT_LENGTH="${req_headers[content-length]:-NULL}" CONTENT_TYPE="$req_headers[content-type]" GATEWAY_INTERFACE="$RVARS[gateway_interface]" QUERY_STRING="${req_headers[querystr]#\?}" REMOTE_ADDR="$client_ip" REMOTE_HOST="NULL" REQUEST_METHOD="$req_headers[method]" SCRIPT_NAME="${1#$RVARS[docroot]}" SERVER_NAME="$RVARS[server_name]" SERVER_ADDR="$RVARS[server_addr]" SERVER_PORT="$VARS[port]" SERVER_PROTOCOL="$RVARS[server_protocol]" SERVER_SOFTWARE="$RVARS[server_software]"

    local -x DOCUMENT_ROOT="$RVARS[docroot]" REQUEST_URI="$req_headers[url]$req_headers[querystr]" SCRIPT_FILENAME="$1" REDIRECT_STATUS=1

    for i in ${(k)req_headers}; do
        case $i in
            ("connection"|"content-length"|"content-type"|"querystr")
                continue;;
            ("method"|"version"|"url")
                continue;;
            (*)
                local -x HTTP_${(U)i:gs/\-/\_}="$req_headers[$i]";;
        esac
    done

    [[ ${1##*.} == "php" ]] && cmd="php-cgi"

    logger_child "Executing cgi script $1"
    coproc { timeout $cmd "$1" <&$fd }
    pid=$!

    while read -r -p line; do
        [[ -z $line || $line == $'\r' ]] && break
        [[ $line =~ "Status:*" ]] && cgi_status_code=${line#Status: }
        cgi_head+=${line%$'\r'}
    done

    if [[ -z ${(M)${cgi_head:l}:#content-type*} ]]; then
        logger_child "ERROR CGI script $1 failed to return MIME-type"
        return 1
    fi

    return_header ${cgi_status_code:-"200 Ok"} "Transfer-Encoding: chunked" $cgi_head[@]
    send_chunk <&p

    if ! wait $pid; then
        logger_child "ERROR executing CGI script $1"
        return_header 500
    fi
}

function handle_file() {
    if check_if_cgi $1; then
        exec_cgi $1
    else
        local -A file_array
        stat -H file_array $1

        local mtype
        mtype=$(mime_type $1)

        if check_if_compression $1; then
            send_compressed_file $1
        else
            send_raw_file $1
        fi
    fi
}

function srv() {
    pathname="${RVARS[docroot]}$(urldecode $req_headers[url])"
    if [[ -f $pathname ]]; then
        [[ $options[globdots] == off && ${pathname:t} == .* ]] && { error_header 403; return }

        handle_file $pathname
    elif [[ -d $pathname ]]; then
        [[ $VARS[follow_symlinks] == 0 && -h ${pathname%/} ]] && { error_header 403; return }

        if [[ -f $pathname/$VARS[index_file] ]]; then
            handle_file $pathname/$VARS[index_file]
        else
            if [[ $pathname != $RVARS[docroot] && $pathname[-1] != "/" ]]; then
                error_header 301 "http://$RVARS[server_addr]:$VARS[port]${pathname#$RVARS[docroot]}/"
                return
            else
                send_list "$pathname" || { error_header 403; return }
            fi
        fi
    else
        error_header 404
        return
    fi

    logger_child "200"
}

function cleanup() {
    for i in ${(SM)jobstates##<->}; do
        kill $i 2>/dev/null
    done

    logger "> Exiting main"
    exec {logfd}>&-; exec {fifofd}>&-
    rm $RVARS[fifo]; ztcp -c
}

function TRAPCHLD() {
    # Flush fifo data so we don't fill up the pipe (do we really care about the child's exit status?)
    while sysread -t 0 -i $fifofd -o 1 1>/dev/null; do
        continue
    done
}

# Main
trap "cleanup; exit" INT KILL TERM

# By default discard logging output
exec {logfd}>/dev/null

# Parse cli options and config file
parse_args $*


# Immutable Vars
RVARS[fifo]=$VARS[fifo_dir]/czhttpd-$$.fifo
RVARS[server_name]="$(ip_addr)"
RVARS[server_addr]="$RVARS[server_name]"
RVARS[server_software]="czhttpd/1.2b"
RVARS[server_protocol]="HTTP/1.1"
RVARS[gateway_interface]="CGI/1.1"

readonly RVARS

for i in ${(Ok)VARS}; do
    logger "$i: $VARS[$i]"
done

http_listen

mkfifo $RVARS[fifo] 2>/dev/null || error "Can not create $RVARS[fifo]"
exec {fifofd}<>$RVARS[fifo]

while :; do
    # Use select to block until a child writes to fifo on exit
    while (( ${#jobstates} >= $VARS[max_conn] )); do
        logger "max connections hit, temporarily unable to fork"
        zselect -r $fifofd && break
    done

    ztcp -a $listenfd

    ( trap "ztcp -c; exit" KILL TERM; trap '' PIPE

    fd=$REPLY

    while read line; do
        [[ $line[3] == "I" ]] && { client_ip=${line[(ws. .)3]}; break }
    done < <(ztcp -L)

    while :; do
        parse_request || { logger_child "empty request, closing"; break }

        if check_request; then
            srv >&$fd 2>/dev/null || { logger_child "broken socket, closing"; break }

            if [[ $VARS[http_keep_alive] == 0 || $req_headers[connection] == "close" ]]; then
                logger_child "connection type: close, closing"
                break
            fi
        fi
    done

    ztcp -c

    print "0" >&$fifofd ) &

    ztcp -c $REPLY
done
